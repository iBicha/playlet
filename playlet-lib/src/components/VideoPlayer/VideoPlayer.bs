#const DEBUG_LOG_VIDEO_QUALITY = false

import "pkg:/components/Dialog/DialogUtils.bs"
import "pkg:/components/JobSystem/Jobs.bs"
import "pkg:/components/JobSystem/JobSystem.bs"
import "pkg:/components/Services/Innertube/Constants.bs"
import "pkg:/components/Services/Invidious/InvidiousToContentNode.bs"
import "pkg:/components/VideoPlayer/Lounge.bs"
import "pkg:/components/VideoPlayer/SponsorBlock.bs"
import "pkg:/components/VideoPlayer/VideoPlayerStyle.bs"
import "pkg:/components/VideoQueue/VideoQueueUtils.bs"
import "pkg:/source/utils/ErrorUtils.bs"
import "pkg:/source/utils/Logging.bs"
import "pkg:/source/utils/RemoteKeys.bs"

enum DownloadErrors
    Unknown = 900
    TimeoutByCurl = 950
    TimeoutBySelector = 951
    Abort = 960
    AbortByServer = 961
    AbortBySelector = 962
    AbortByParallel = 963
    ParallelFragmentError = 964
    BadMedia = 970
end enum

function Init()
    SetPlayerStyle()
    SetupAnimation()
    m.fullScreenHint = m.top.findNode("fullScreenHint")
    m.fullScreenHintLabel = m.top.findNode("fullScreenHintLabel")
    m.fullScreenHintTimer = m.top.findNode("fullScreenHintTimer")
    m.fullScreenHintTimer.ObserveField("fire", FuncName(OnFullScreenHintTimer))
    m.trickplayUITimer = m.top.findNode("trickplayUITimer")
    m.trickplayUITimer.ObserveField("fire", FuncName(OnTrickplayUITimer))
    m.top.notificationInterval = 1

    ' videoPlayingSuccess indicates if we started playing a video successfully
    ' We use it to detect if we should try another link for a video, or if another error
    ' occurred (such as a network error)
    m.videoPlayingSuccess = false
    ' ignoreNextFinishedState indicates if we should ignore the next finished state
    ' This is used to prevent the video from playing the next video when we are
    ' still trying to find a working stream url.
    ' This is also used to prevent playing the next video when we're still displaying
    ' an error dialog.
    m.ignoreNextFinishedState = false

    ' Indicates that we're currently paused and seeking position
    m.isSeekingPosition = false

    ' Checks if current RokuOS version has showUI field in Video node
    m.showUIEnabled = m.top.hasField("showUI")
    LogDebug(`Custom OK handler is ${m.showUIEnabled ? "enabled" : "disabled"}`)

    m.statsOverlayEnabled = false
    m.statsResolution = ""
    m.statsBitrate = invalid
    m.statsFps = ""

    ' asyncStopSemantics available since Roku OS 12.5
    ' It is set to true because stopping synchronously causes timeout and crash
    ' Usually we would need to wait for the video state to move to "stopping" then to "stopped"
    ' before considering the video node closed, and creating a new one.
    ' However, since we have a job to load video details, there should be enough time for the
    ' video node to close before we create a new one.
    if m.top.hasField("asyncStopSemantics")
        m.top.asyncStopSemantics = true
    end if

    httpAgent = m.top.getHttpAgent()
    ' TODO:P2 user agent should not be hardcoded, it should be part of video metadata
    httpAgent.AddHeader("User-Agent", VIDEO_PLAYER_USER_AGENT)

    #if DEBUG_LOG_VIDEO_QUALITY
        m.top.addFields({
            "_resolution": ""
            "_audioFormat": ""
            "_videoFormat": ""
        })

        m.top.observeField("streamingSegment", FuncName(OnStreamingSegmentChangeDebug))

        m.top.observeField("audioFormat", FuncName(OnFormatChangeDebug))
        m.top.observeField("videoFormat", FuncName(OnFormatChangeDebug))
        m.top.observeField("_resolution", FuncName(OnFormatChangeDebug))

        m.top.observeField("_audioFormat", FuncName(OnQualityChangeDebug))
        m.top.observeField("_videoFormat", FuncName(OnQualityChangeDebug))
    #end if
end function

#if DEBUG_LOG_VIDEO_QUALITY
    function OnStreamingSegmentChangeDebug()
        segment = m.top.streamingSegment
        width = segment.width
        height = segment.height
        if width > 0 and height > 0
            m.top._resolution = `${width}x${height}`
        end if
    end function

    function OnFormatChangeDebug()
        audioFormat = m.top.audioFormat
        videoFormat = m.top.videoFormat
        resolution = m.top._resolution

        m.top._audioFormat = audioFormat
        m.top._videoFormat = `${videoFormat} ${resolution}`
    end function

    function OnQualityChangeDebug()
        LogDebug("Video format:", m.top._videoFormat, "Audio format:", m.top._audioFormat)
    end function
#end if

function OnNodeReady()
    minRect = m.top.minRect
    rect = m.container.fullscreen ? m.top.maxRect : minRect

    m.top.width = rect.width
    m.top.height = rect.height
    m.top.translation = [rect.x, rect.y]

    m.fullScreenHint.width = minRect.width
    m.fullScreenHintLabel.width = minRect.width
    m.fullScreenHint.translation = [0, minRect.height - m.fullScreenHint.height]

    ' TODO:P2 show a loading spinner if video is loading minimized
    ' Probably only worth doing after the video player is redone
    m.top.enableUI = m.container.fullscreen
    m.top.showFullScreenHint = not m.container.fullscreen

    m.container.observeFieldScoped("fullscreen", FuncName(OnFullScreenChange))
    m.top.ObserveField("state", FuncName(OnVideoPlayerStateChange))

    SetupStatsOverlay()
    SponsorBlock.SetupSponsorBlock()
end function

function PlayWithContent(contentNode as object)
    videoContentNode = CreateObject("roSGNode", "ContentNode")

    if not StringUtils.IsNullOrEmpty(contentNode.videoId)
        videoContentNode.AddFields({ videoId: contentNode.videoId })
    end if
    if ValidInt(contentNode.timestamp) <> -1
        videoContentNode.AddFields({ timestamp: contentNode.timestamp })
    else if contentNode.percentDurationWatched > 0 and contentNode.percentDurationWatched < 100
        videoContentNode.AddFields({ percentDurationWatched: contentNode.percentDurationWatched })
    end if
    if not StringUtils.IsNullOrEmpty(contentNode.title)
        videoContentNode.title = contentNode.title
    end if
    ' NOTE: "_author" not "author". See PlaylistContentNode.xml for explanation.
    author = contentNode._author
    if StringUtils.IsNullOrEmpty(author)
        lines = contentNode.lines
        if IsArray(lines) and lines.Count() > 0
            author = lines[0]
        end if
    end if
    if not StringUtils.IsNullOrEmpty(author)
        videoContentNode.secondaryTitle = author
    end if
    metadata = contentNode.metadata
    if IsAssociativeArray(metadata)
        videoContentNode.AddFields({ metadata: metadata })
    end if

    StartVideoContentJob(videoContentNode)
    Lounge.SendNowPlayingLoading(contentNode.videoId)
end function

function StartVideoContentJob(videoContentNode as object)
    if m.videoContentJob <> invalid
        m.videoContentJob.cancel = true
    end if

    m.top.content = videoContentNode


    input = {
        content: videoContentNode
        invidious: m.top.invidious
        innertube: m.top.innertube
        preferences: m.top.preferences
        loungeService: m.top.loungeService
        playletServerPort: m.top.webServer.port
    }

    m.videoContentJob = JobSystem.CreateCallback(OnVideoContentJobDone)
    JobSystem.QueueJob(m.jobQueue, Jobs.VideoContentJob, input, m.videoContentJob)
end function

function OnVideoContentJobDone(event as object) as void
    JobSystem.UnobserveCallback(event.getRoSGNode())
    m.videoContentJob = invalid

    info = event.getInfo()
    if info.cancel or m.onCloseCalled = true
        return
    end if

    content = m.top.content

    if not info.success
        videoId = ""
        if content <> invalid
            videoId = content.videoId
        end if

        title = Tr(Locale.VideoPlayer.VideoLoadError)
        message = Tr(Locale.VideoPlayer.VideoLoadErrorMessage).Replace("%1", videoId) + `\n${info.error}`
        buttons = [Tr(Locale.Buttons.PlayNextVideo), Tr(Locale.Buttons.Cancel)]

        dialog = DialogUtils.ShowTimedDialogButtons(message, title, buttons, 0, 10, true)
        if dialog <> invalid
            dialog.observeFieldScoped("wasClosed", FuncName(OnVideoContentJobErrorDialogResponse))
        else
            OnVideoContentJobErrorDialogResponse(invalid)
        end if

        Lounge.SendOnStateChange()
        return
    end if

    metadata = content.metadata
    SponsorBlock.FetchSponsorBlock(metadata)

    SeekToInitialPosition(content)

    PlayAfterPreviousPlayerHasStopped()
    MarkVideoWatched(content.videoId, metadata.playbackTrackingUrls)
end function

function SeekToInitialPosition(content as object) as void
    if content = invalid
        return
    end if

    ' For trickplay of live streams, apps should seek to a position of
    ' 999,999 seconds (for both DASH and HLS streams). The Roku media
    ' player clips that position to the current availability window and
    ' provides a robust buffer.
    ' https://developer.roku.com/en-ca/docs/specs/media/streaming-specifications.md
    if content.Live = true
        LogInfo("Seeking to enge of live stream")
        m.top.seek = 999999
        return
    end if

    timestamp = ValidInt(content.timestamp)
    if timestamp > 0
        LogInfo("Seeking to timestamp:", timestamp)
        m.top.seek = content.timestamp
        return
    end if

    percentDurationWatched = ValidFloat(content.percentDurationWatched)
    if percentDurationWatched > 0
        m.seekToPercent = percentDurationWatched
        SeekToPercentOfDuration()
    end if
end function

function SeekToPercentOfDuration() as void
    m.top.UnobserveField("duration")

    seekToPercent = m.seekToPercent
    if seekToPercent = invalid
        return
    end if

    duration = m.top.duration
    if duration = 0
        ' If the duration is not available, wait for it to be set
        m.top.ObserveField("duration", FuncName(SeekToPercentOfDuration))
        return
    end if

    ' If the stream is less than 30 seconds, it's not worth seeking
    if duration < 30
        return
    end if

    m.seekToPercent = invalid
    seek = (MathUtils.Clamp(seekToPercent, 0, 100) / 100.0) * duration
    if seek > 0
        LogInfo("Seeking to percent duration watched", seek)
        m.top.seek = seek
    end if
end function

function PlayAfterPreviousPlayerHasStopped() as void
    previousPlayer = m.top.previousPlayer
    m.top.previousPlayer = invalid

    if previousPlayer = invalid
        m.top.control = "play"
        return
    end if

    previousPlayerState = previousPlayer.state
    LogInfo("Previous player state:", previousPlayerState)

    if previousPlayerState = "stopping"
        previousPlayer.observeFieldScoped("state", FuncName(OnPreviousPlayerState))
        return
    end if

    m.top.control = "play"
end function

function OnPreviousPlayerState(event as object) as void
    previousPlayer = event.getRoSGNode()

    if m.onCloseCalled = true
        previousPlayer.unobserveFieldScoped("state")
        return
    end if

    previousPlayerState = previousPlayer.state
    LogInfo("Previous player state change:", previousPlayerState)

    if previousPlayerState = "stopped" or previousPlayerState = "error" or previousPlayerState = "finished" or previousPlayerState = "none"
        previousPlayer.unobserveFieldScoped("state")

        m.top.control = "play"
    end if
end function

function OnVideoContentJobErrorDialogResponse(event as object)
    shouldPlayNext = false
    if event <> invalid
        dialog = event.getRoSGNode()
        dialog.unobserveFieldScoped("wasClosed")
        shouldPlayNext = dialog.actualButtonSelected = 0
    end if

    if not shouldPlayNext or not VideoQueueUtils.PlayNext(m.videoQueue, m.invidious, m.preferences)
        if m.top.isSameNode(m.videoQueue.player)
            m.videoQueue.closePlayer = true
        end if
    end if

    Lounge.SendOnStateChange()
end function

function MarkVideoWatched(videoId as dynamic, playbackTrackingUrls as dynamic) as void
    if StringUtils.IsNullOrEmpty(videoId)
        return
    end if

    invidious = m.top.invidious
    authToken = invidious.authToken
    if authToken = invalid
        return
    end if

    if m.markVideoWatchedJob <> invalid
        m.markVideoWatchedJob.cancel = true
    end if

    profileType = authToken.profileNode.type

    input = {
        videoId: videoId
        invidious: invidious
        authToken: authToken
        profileType: profileType
        playbackTrackingUrls: playbackTrackingUrls
    }

    m.markVideoWatchedJob = JobSystem.CreateCallback()
    m.markVideoWatchedJob.addField("watchTime", "float", false)
    JobSystem.QueueJob(m.jobQueue, Jobs.MarkVideoWatchedJob, input, m.markVideoWatchedJob)

    if profileType <> "youtube"
        return
    end if

    ' Progress reported to Innertube. It is the position in seconds,
    ' with 20 second steps.
    m.watchTimeMarker = -1
    m.top.ObserveFieldScoped("position", FuncName(OnPositionChangeMarkWatchTime))
end function

function OnPositionChangeMarkWatchTime(event as object) as void
    if m.markVideoWatchedJob = invalid
        return
    end if

    currentPosition = event.getData()
    currentWatchTimeMarker = m.watchTimeMarker
    m.watchTimeMarker = (currentPosition \ 20) * 20
    if currentWatchTimeMarker = currentPosition
        return
    end if
    m.markVideoWatchedJob.watchTime = m.watchTimeMarker
end function

function OnClose()
    m.onCloseCalled = true

    m.top.previousPlayer = invalid

    if m.markVideoWatchedJob <> invalid
        m.markVideoWatchedJob.cancel = true
        m.markVideoWatchedJob = invalid
    end if
    if m.videoContentJob <> invalid
        m.videoContentJob.cancel = true
        m.videoContentJob = invalid
    end if
    if m.sponsorBlockSegmentsJob <> invalid
        m.sponsorBlockSegmentsJob.cancel = true
        m.sponsorBlockSegmentsJob = invalid
    end if

    parent = m.top.getParent()
    if parent <> invalid
        parent.RemoveChild(m.top)
    end if
    SponsorBlock.RemoveNotifcation(m.notifications)

    ' Stopping a video is slow and synchronous, and can lead to execution timeout crashes.
    try
        m.top.control = "stop"
    catch error
        errorMessage = ErrorUtils.Format(error)
        LogError("Error stopping video:", errorMessage)
        DialogUtils.ShowDialogEx({
            message: errorMessage
            title: Tr(Locale.VideoPlayer.ErrorClosingVideo)
            large: true
        })
    end try

    m.top.content = invalid
end function

function OnVideoPlayerStateChange() as void
    Lounge.SendOnStateChange()

    state = m.top.state
    content = m.top.content

    ' Reset isSeekingPosition when started to play the video
    if state = "playing"
        m.isSeekingPosition = false
    end if

    ' If we successfully played the video, then any error that comes later is not due to a 403 (FORBIDDEN).
    ' This is to reduce false positives, as we do not want retry another link if the first link is working fine.
    if state = "playing" and not m.videoPlayingSuccess
        LogInfo(`Now playing video ${content.url}`)
        m.videoPlayingSuccess = true
    end if

    errorData = invalid
    if state = "error"
        errorInfo = m.top.errorInfo
        errorData = GetPlayerErrorData(content.videoId, errorInfo)

        LogErrorNoTelemetry(errorData.title, errorData.body)

        if m.videoPlayingSuccess <> true
            ' http for stream format, mediaerror for DASH
            if errorInfo.category = "http" or errorInfo.category = "mediaerror"
                playletStreamUrls = content.playletStreamUrls
                currentUrlIndex = content.playletStreamUrlIndex
                nextUrlIndex = currentUrlIndex + 1
                content.playletStreamUrlIndex = nextUrlIndex
                if nextUrlIndex < playletStreamUrls.Count()
                    currentUrl = content.url
                    nextUrl = playletStreamUrls[nextUrlIndex]

                    if StringUtils.IsNullOrEmpty(nextUrl)
                        LogError("Next stream URL is empty, cannot try next stream")
                    end if

                    content.url = nextUrl

                    SeekToInitialPosition(content)

                    ' This video errored, and is about to finish, so don't close the video yet
                    ' That's why we should ignore the next "finished" event
                    m.ignoreNextFinishedState = true
                    m.top.control = "play"

                    timestamp = content.timestamp
                    hasTimestamp = IsInt(timestamp)

                    if hasTimestamp and timestamp > 0
                        m.top.seek = content.timestamp
                    end if

                    msg = `Stream ${currentUrl} failed to play. Trying next stream ${nextUrl}`
                    LogErrorNoTelemetry(msg)

                    errorData.title = msg + `\n` + errorData.title
                    ReportVideoError(errorData, currentUrl, playletStreamUrls, currentUrlIndex, false)
                    return
                end if
            end if
        end if
    end if

    if state = "finished" and m.ignoreNextFinishedState = true
        m.ignoreNextFinishedState = false
        return
    end if

    if state = "finished"
        OnVideoFinished()
        return
    end if

    if state = "error"
        LogErrorNoTelemetry(errorData.title, errorData.body)
        ReportVideoError(errorData, content.url, content.playletStreamUrls, content.playletStreamUrlIndex, true)

        buttons = [Tr(Locale.Buttons.PlayNextVideo), Tr(Locale.Buttons.Cancel)]

        dialog = DialogUtils.ShowTimedDialogButtons(errorData.body, errorData.title, buttons, 0, 10, true)
        if dialog <> invalid
            dialog.observeFieldScoped("wasClosed", FuncName(OnVideoContentJobErrorDialogResponse))
        else
            OnVideoContentJobErrorDialogResponse(invalid)
        end if
        m.ignoreNextFinishedState = true
    end if
end function

function GetPlayerErrorData(videoId as string, errorInfo as object) as object
    if errorInfo = invalid
        return invalid
    end if

    errorMsg = m.top.errorMsg
    errorCode = m.top.errorCode
    errorStr = m.top.errorStr

    title = Tr(Locale.VideoPlayer.ErrorPlayingVideo).Replace("%1", videoId)
    body = `errorMsg: ${errorMsg}\nerrorCode: ${errorCode}\nerrorStr: ${errorStr}`
    for each key in errorInfo
        body += `\n${key}: ${errorInfo[key]}`
    end for

    fingerprint = [
        Locale.VideoPlayer.ErrorPlayingVideo
        errorMsg
        errorCode
        errorInfo.source
        errorInfo.ignored
        errorInfo.category
        errorInfo.errcode
        errorInfo.drmerrcode
    ]

    return {
        title: title
        body: body
        fingerprint: fingerprint
    }
end function

function ReportVideoError(errorData as object, url as dynamic, urls as object, urlIndex as dynamic, shownInDialog as boolean) as void
    attachments = invalid
    if errorData.body.Instr("malformed data") <> -1 or errorData.body.Instr("invalid pathname") <> -1
        lastGeneratedDash = ValidString(ReadAsciiFile("cachefs:/last_generated_dash.xml"))
        lastGeneratedHls = ValidString(ReadAsciiFile("cachefs:/last_generated_hls.m3u8"))
        lastPlayerResponse = ValidString(ReadAsciiFile("cachefs:/last_player_response.json"))

        attachments = [{
            filename: "last_generated_dash.xml"
            content_type: "plain/text"
            data: lastGeneratedDash
        }, {
            filename: "last_generated_hls.m3u8"
            content_type: "plain/text"
            data: lastGeneratedHls
        }, {
            filename: "last_player_response.json"
            content_type: "application/json"
            data: lastPlayerResponse
        }]
    end if

    position = m.top.position
    duration = m.top.duration
    message = [
        errorData.title
        errorData.body
        `Dialog shown: ${shownInDialog}`
        `Position: ${position}`
        `Duration: ${duration}`
        `Url: ${url}`
        `Urls: ` + ToString(urls)
        `Url index: ${urlIndex}`
    ].Join(`\n`)

    errorData.fingerprint.push(shownInDialog)

    if shownInDialog
        level = "error"
    else
        level = "warning"
    end if

    LogTelemetryEvent({
        level: level
        message: message
        fingerprint: errorData.fingerprint
        attachments: attachments
    })
end function

function OnVideoFinished() as void
    if not VideoQueueUtils.PlayNext(m.videoQueue, m.invidious, m.preferences)
        m.videoQueue.closePlayer = true
    end if
end function

function IsLiveVideo() as boolean
    content = m.top.content
    return content <> invalid and content.Live = true
end function

function ShowUIAndStartTimer()
    if m.showUIEnabled
        m.top.showUI = { "show": true, "trickPlaybar": true, "titleAndTime": true, "trickplayBackgroundOverlay": true, "focusTrickplayBar": false }
        m.trickplayUITimer.control = "start"
    end if
end function

function HideUIAndStopTimer()
    if m.showUIEnabled
        m.top.showUI = { "show": false, "focusTrickplayBar": false }
        m.trickplayUITimer.control = "stop"
    end if
end function

function HandleOKPress() as boolean
    if SponsorBlock.ManualSkipSegment()
        return false
    end if

    if not m.showUIEnabled
        return false
    end if

    handled = false
    state = m.top.state
    uiVisible = m.top.trickPlaybar.visible
    isLive = IsLiveVideo()
    LogDebug(`Handling OK button: state = ${state}, uiVisible = ${uiVisible} isLive = ${isLive}`)
    if state = "playing"
        if not uiVisible
            ' Video is playing and UI is not visible, show it
            ShowUIAndStartTimer()
        else if not isLive
            ' Trickplay bar is visible and video is currently played, pause it and retain the UI
            m.trickplayUITimer.control = "stop"
            m.top.control = "pause"
            ShowUIAndStartTimer()
        else
            HideUIAndStopTimer()
        end if
        handled = true
    else if state = "paused"
        ' Exit early if we're in seeking mode to avoid messing up internal Video node state
        if m.isSeekingPosition
            return false
        end if

        if not uiVisible
            ' Video is paused and UI is not visible, show it
            ShowUIAndStartTimer()
        else
            ' Video is currently paused with visible UI, resume it and hide UI
            HideUIAndStopTimer()
            m.top.control = "resume"
        end if
        handled = true
    end if
    return handled
end function

function OnKeyEvent(key as string, press as boolean) as boolean
    if press = false
        return false
    end if
    ' Unfortunately, a Video node cannot capture the "options" key (because, Roku...)
    ' https://community.roku.com/t5/Roku-Developer-Program/Bug-in-10-0-1-Options-key-is-not-being-consumed-by-onKeyEvent-when-Video-node-is-in-focus/m-p/709200/highlight/true#M49312
    ' Because of that, the button "down" is used to shrink the video for picture in picture mode
    if key = RemoteKeys.Down
        if VideoQueueUtils.ToggleVideoPictureInPicture(m.videoQueue)
            return true
        end if
    end if

    if key = RemoteKeys.Back
        m.videoQueue.closePlayer = true
        return true
    end if

    if key = RemoteKeys.Ok
        return HandleOKPress()
    end if

    if key = RemoteKeys.Left or key = RemoteKeys.Right or key = RemoteKeys.Rewind or key = RemoteKeys.FastForward
        ' We're paused and one of the buttons is pressed: left, right ff, rw.
        ' That means we're seeking position. Check that in HandleOKPress and exit early
        m.isSeekingPosition = true
    end if

    ' Always stop UI timer when pressing any button to avoid UI being hidden twice
    m.trickplayUITimer.control = "stop"
    return false
end function

function SetupAnimation()
    m.minimizeAnimation = m.top.findNode("minimizeAnimation")
    m.widthInterpolator = m.top.findNode("widthInterpolator")
    m.heightInterpolator = m.top.findNode("heightInterpolator")
    m.translationInterpolator = m.top.findNode("translationInterpolator")

    minRect = m.top.minRect
    maxRect = m.top.maxRect

    m.widthInterpolator.keyValue = [maxRect.width, (maxRect.width + minRect.width) / 2, minRect.width]
    m.heightInterpolator.keyValue = [maxRect.height, (maxRect.height + minRect.height) / 2, minRect.height]
    maxTranslation = [maxRect.x, maxRect.y]
    minTranslation = [minRect.x, minRect.y]
    midTranslation = [(maxRect.x + minRect.x) / 2, (maxRect.y + minRect.y) / 2]
    m.translationInterpolator.keyValue = [maxTranslation, midTranslation, minTranslation]
end function

function OnFullScreenChange()
    HideUIAndStopTimer()

    m.widthInterpolator.reverse = m.container.fullscreen
    m.heightInterpolator.reverse = m.container.fullscreen
    m.translationInterpolator.reverse = m.container.fullscreen

    m.minimizeAnimation.control = "start"

    m.top.enableUI = m.container.fullscreen
    m.top.showFullScreenHint = not m.container.fullscreen

    SponsorBlock.SetVisible(m.notifications, m.container.fullscreen)
    UpdateStatsOverlayVisibility()
end function

function OnShowFullScreenHint() as void
    m.fullScreenHintTimer.control = "stop"

    if m.container.fullscreen
        m.fullScreenHint.visible = false
        return
    end if

    if m.top.showFullScreenHint
        ' Take 1 second until the shrink animation finishes to show the hint
        m.fullScreenHintTimer.duration = 1
    else
        ' Wait 5 seconds then hide the hint
        m.fullScreenHintTimer.duration = 5
    end if

    m.fullScreenHintTimer.control = "start"
end function

function OnTrickplayUITimer()
    HideUIAndStopTimer()
end function

function OnFullScreenHintTimer()
    showFullScreenHint = m.top.showFullScreenHint
    m.fullScreenHint.visible = showFullScreenHint
    if showFullScreenHint
        m.top.showFullScreenHint = false
    end if
end function

function SetupStatsOverlay() as void
    m.statsOverlay = m.top.findNode("statsOverlay")
    m.statsOverlayLabel = m.top.findNode("statsOverlayLabel")
    m.statsOverlayTimer = m.top.findNode("statsOverlayTimer")

    if m.statsOverlayTimer <> invalid
        m.statsOverlayTimer.ObserveField("fire", FuncName(OnStatsOverlayTimer))
    end if

    if m.top.hasField("streamingSegment")
        m.top.ObserveField("streamingSegment", FuncName(OnStreamingSegmentChangeStats))
    end if
    m.top.ObserveField("audioFormat", FuncName(UpdateStatsOverlay))
    m.top.ObserveField("videoFormat", FuncName(UpdateStatsOverlay))
    m.top.ObserveField("state", FuncName(UpdateStatsOverlay))
    m.top.ObserveField("content", FuncName(UpdateStatsOverlay))

    if m.top.preferences <> invalid
        m.top.preferences.observeFieldScoped("playback.stats_for_nerds", FuncName(OnStatsPreferenceChange))
    end if
    OnStatsPreferenceChange()
end function

function OnStatsPreferenceChange() as void
    enabled = false
    if m.top.preferences <> invalid
        enabled = m.top.preferences["playback.stats_for_nerds"] = true
    end if
    m.statsOverlayEnabled = enabled
    UpdateStatsOverlayVisibility()
end function

function UpdateStatsOverlayVisibility() as void
    if m.statsOverlay = invalid
        return
    end if

    visible = m.statsOverlayEnabled
    if m.container <> invalid and not m.container.fullscreen
        visible = false
    end if

    m.statsOverlay.visible = visible
    if m.statsOverlayTimer <> invalid
        m.statsOverlayTimer.control = visible ? "start" : "stop"
    end if
    if visible
        UpdateStatsOverlay()
    end if
end function

function OnStatsOverlayTimer() as void
    UpdateStatsOverlay()
end function

function OnStreamingSegmentChangeStats() as void
    segment = m.top.streamingSegment
    if not IsAssociativeArray(segment)
        return
    end if

    m.statsBitrate = invalid

    width = segment.width
    height = segment.height
    if width > 0 and height > 0
        m.statsResolution = `${width}x${height}`
    end if

    if segment.DoesExist("fps")
        m.statsFps = ToString(segment.fps)
    else if segment.DoesExist("frameRate")
        m.statsFps = ToString(segment.frameRate)
    end if

    bitrate = ExtractSegmentBitrate(segment)
    if bitrate <> invalid
        m.statsBitrate = bitrate
    else
        inferred = InferBitrateFromMetadata()
        if inferred <> invalid
            m.statsBitrate = inferred
        end if
    end if

    UpdateStatsOverlay()
end function

function UpdateStatsOverlay() as void
    if m.statsOverlay = invalid or not m.statsOverlay.visible or m.statsOverlayLabel = invalid
        return
    end if

    lines = []

    state = ValidString(m.top.state)
    if not StringUtils.IsNullOrEmpty(state)
        lines.Push(`State: ${state}`)
    end if

    url = ""
    if m.top.content <> invalid
        url = ValidString(m.top.content.url)
    end if

    query = ParseUrlQuery(url)
    containerParam = ExtractQueryValue(query, "container")
    if not StringUtils.IsNullOrEmpty(containerParam)
        container = containerParam
    else
        container = InferContainerFromUrl(url)
    end if
    if not StringUtils.IsNullOrEmpty(container)
        lines.Push(`Container: ${container}`)
    end if

    quality = ExtractQueryValue(query, "quality")
    if not StringUtils.IsNullOrEmpty(quality)
        if quality.InStr(",") <> -1
            quality = quality.Split(",")[0].Trim()
        end if
        lines.Push(`Quality: ${quality}`)
        if StringUtils.IsNullOrEmpty(m.statsResolution)
            m.statsResolution = quality
        end if
    end if

    videoFormat = ValidString(m.top.videoFormat)
    if not StringUtils.IsNullOrEmpty(videoFormat)
        lines.Push(`Video format: ${videoFormat}`)
        parsedVideo = ParseMimeType(videoFormat)
        if not StringUtils.IsNullOrEmpty(parsedVideo.codec)
            lines.Push(`Video codec: ${parsedVideo.codec}`)
        end if
    end if

    audioFormat = ValidString(m.top.audioFormat)
    if not StringUtils.IsNullOrEmpty(audioFormat)
        lines.Push(`Audio format: ${audioFormat}`)
        parsedAudio = ParseMimeType(audioFormat)
        if not StringUtils.IsNullOrEmpty(parsedAudio.codec)
            lines.Push(`Audio codec: ${parsedAudio.codec}`)
        end if
    end if

    resolution = m.statsResolution
    if not StringUtils.IsNullOrEmpty(resolution)
        resLine = `Resolution: ${resolution}`
        if not StringUtils.IsNullOrEmpty(m.statsFps)
            resLine = resLine + ` @${m.statsFps}fps`
        end if
        lines.Push(resLine)
    end if

    if m.statsBitrate = invalid
        inferred = InferBitrateFromMetadata()
        if inferred <> invalid
            m.statsBitrate = inferred
        end if
    end if

    bitrate = FormatBitrate(m.statsBitrate)
    if not StringUtils.IsNullOrEmpty(bitrate)
        lines.Push(`Bitrate: ${bitrate}`)
    end if

    positionText = FormatTime(m.top.position)
    durationText = FormatTime(m.top.duration)
    if not StringUtils.IsNullOrEmpty(positionText) or not StringUtils.IsNullOrEmpty(durationText)
        lines.Push(`Position: ${positionText} / ${durationText}`)
    end if

    if not StringUtils.IsNullOrEmpty(url)
        lines.Push(`Source: ${TruncateString(url, 140)}`)
    end if

    if lines.Count() = 0
        lines.Push("Stats unavailable")
    end if

    m.statsOverlayLabel.text = lines.Join(`\n`)
end function

function InferContainerFromUrl(url as string) as string
    if StringUtils.IsNullOrEmpty(url)
        return ""
    end if

    lower = LCase(url)
    if lower.InStr(".mpd") <> -1 or lower.InStr("/dash") <> -1 or lower.InStr("/mux") <> -1
        return "dash"
    end if
    if lower.InStr(".m3u8") <> -1
        return "hls"
    end if
    if lower.InStr(".webm") <> -1
        return "webm"
    end if
    if lower.InStr(".mkv") <> -1
        return "mkv"
    end if
    if lower.InStr(".mp4") <> -1
        return "mp4"
    end if

    return ""
end function

function ParseUrlQuery(url as string) as object
    if StringUtils.IsNullOrEmpty(url)
        return {}
    end if
    if url.InStr("?") = -1
        return {}
    end if
    return UrlUtils.ParseQueryComponents(url)
end function

function ExtractQueryValue(query as object, key as string) as string
    if query = invalid or StringUtils.IsNullOrEmpty(key)
        return ""
    end if
    if not query.DoesExist(key)
        return ""
    end if

    value = query[key]
    if IsArray(value)
        if value.Count() = 0
            return ""
        end if
        value = value[0]
    end if

    return ValidString(value)
end function

function ParseMimeType(mimeType as string) as object
    result = { container: "", codec: "" }
    if StringUtils.IsNullOrEmpty(mimeType)
        return result
    end if

    parts = mimeType.Split(";")
    typePart = parts[0].Trim()
    slashIndex = typePart.InStr("/")
    if slashIndex <> -1
        result.container = typePart.Mid(slashIndex + 1)
    end if

    for each part in parts
        trimmed = part.Trim()
        if trimmed.StartsWith("codecs=")
            codecList = trimmed.Mid(7)
            codecList = codecList.Replace(chr(34), "")
            codecList = codecList.Replace("'", "")
            result.codec = codecList
            exit for
        end if
    end for

    return result
end function

function FormatBitrate(value as dynamic) as string
    bitrate = ParseNumeric(value)
    if bitrate = invalid or bitrate <= 0
        return ""
    end if

    kbps = bitrate \ 1000
    if kbps <= 0
        return `${bitrate} bps`
    end if
    return `${kbps} kbps`
end function

function FormatTime(value as dynamic) as string
    seconds = NormalizeSeconds(value)
    if seconds < 0
        return ""
    end if

    hours = seconds \ 3600
    minutes = (seconds mod 3600) \ 60
    secs = seconds mod 60

    if hours > 0
        return `${hours}:${Pad2(minutes)}:${Pad2(secs)}`
    end if
    return `${minutes}:${Pad2(secs)}`
end function

function Pad2(value as integer) as string
    if value < 10
        return "0" + value.ToStr()
    end if
    return value.ToStr()
end function

function TruncateString(value as string, maxLen as integer) as string
    if value.Len() <= maxLen
        return value
    end if
    return value.Left(maxLen) + "..."
end function

function NormalizeSeconds(value as dynamic) as integer
    if IsInt(value)
        return value
    end if
    if IsFloat(value)
        return CInt(value)
    end if
    if IsDouble(value)
        return CInt(value)
    end if
    if IsString(value)
        return CInt(Val(value))
    end if
    return -1
end function

function ParseNumeric(value as dynamic) as dynamic
    if IsInt(value)
        return value
    end if
    if IsFloat(value)
        return CInt(value)
    end if
    if IsDouble(value)
        return CInt(value)
    end if
    if IsString(value)
        parsed = Val(value)
        if parsed > 0
            return CInt(parsed)
        end if
    end if
    return invalid
end function

function ExtractSegmentBitrate(segment as object) as dynamic
    if segment = invalid
        return invalid
    end if

    keys = ["bitrate", "bandwidth", "bitsPerSecond", "bps"]
    for each key in keys
        if segment.DoesExist(key)
            value = ParseNumeric(segment[key])
            if value <> invalid
                return value
            end if
        end if
    end for

    return invalid
end function

function InferBitrateFromMetadata() as dynamic
    content = m.top.content
    if content = invalid
        return invalid
    end if

    metadata = content.metadata
    if not IsAssociativeArray(metadata)
        return invalid
    end if

    targetHeight = ParseResolutionHeight(m.statsResolution)
    if targetHeight <= 0
        return invalid
    end if

    bestBitrate = 0
    formats = ValidArray(metadata.adaptiveFormats)
    if formats.Count() = 0
        formats = ValidArray(metadata.formatStreams)
    end if

    for each fmt in formats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        height = ParseFormatHeight(fmt)
        if height <> targetHeight
            continue for
        end if

        bitrate = ParseNumeric(fmt["bitrate"])
        if bitrate <> invalid and bitrate > bestBitrate
            bestBitrate = bitrate
        end if
    end for

    if bestBitrate > 0
        return bestBitrate
    end if

    return invalid
end function

function ParseFormatHeight(fmt as object) as integer
    if fmt = invalid
        return 0
    end if

    heightValue = fmt["height"]
    if IsInt(heightValue)
        return heightValue
    end if
    if IsFloat(heightValue) or IsDouble(heightValue)
        return CInt(heightValue)
    end if

    size = ValidString(fmt["size"])
    if not StringUtils.IsNullOrEmpty(size)
        heightFromSize = ParseResolutionHeight(size)
        if heightFromSize > 0
            return heightFromSize
        end if
    end if

    resolution = ValidString(fmt["resolution"])
    if not StringUtils.IsNullOrEmpty(resolution)
        return ParseResolutionHeight(resolution)
    end if

    return 0
end function

function ParseResolutionHeight(value as string) as integer
    if StringUtils.IsNullOrEmpty(value)
        return 0
    end if

    lower = LCase(value)
    if lower.InStr("x") <> -1
        parts = lower.Split("x")
        if parts.Count() >= 2
            return CInt(Val(parts[1]))
        end if
    end if

    if lower.InStr("p") <> -1
        return CInt(Val(lower.Replace("p", "")))
    end if

    return CInt(Val(lower))
end function
