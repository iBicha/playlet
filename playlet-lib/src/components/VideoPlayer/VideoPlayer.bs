#const DEBUG_LOG_VIDEO_QUALITY = false

import "pkg:/components/Dialog/DialogUtils.bs"
import "pkg:/components/JobSystem/Jobs.bs"
import "pkg:/components/JobSystem/JobSystem.bs"
import "pkg:/components/Navigation/Navigation.bs"
import "pkg:/components/Services/Innertube/Constants.bs"
import "pkg:/components/Services/Invidious/InvidiousService.bs"
import "pkg:/components/Services/Invidious/InvidiousToContentNode.bs"
import "pkg:/components/VideoPlayer/Lounge.bs"
import "pkg:/components/VideoPlayer/PictureInPicture.bs"
import "pkg:/components/VideoPlayer/PlayerUi.bs"
import "pkg:/components/VideoPlayer/SponsorBlock.bs"
import "pkg:/components/VideoQueue/VideoQueueUtils.bs"
import "pkg:/source/utils/DisposableObserve.bs"
import "pkg:/source/utils/ErrorUtils.bs"
import "pkg:/source/utils/FocusManagement.bs"
import "pkg:/source/utils/Locale.bs"
import "pkg:/source/utils/Logging.bs"
import "pkg:/source/utils/MathUtils.bs"
import "pkg:/source/utils/RemoteKeys.bs"
import "pkg:/source/utils/StringUtils.bs"
import "pkg:/source/utils/Types.bs"
import "pkg:/source/utils/UrlUtils.bs"

enum DownloadErrors
    Unknown = 900
    TimeoutByCurl = 950
    TimeoutBySelector = 951
    Abort = 960
    AbortByServer = 961
    AbortBySelector = 962
    AbortByParallel = 963
    ParallelFragmentError = 964
    BadMedia = 970
end enum

const SKIP_SECONDS = 10

function Init()
    InitializePlayerUi()

    httpAgent = m.top.getHttpAgent()
    httpAgent.AddHeader("User-Agent", VIDEO_PLAYER_USER_AGENT)

    m.ccEnabled = false
    m.videoPlayingSuccess = false
    m.ignoreNextFinishedState = false
    m.isSeekingPosition = false

    m.statsOverlayEnabled = false
    m.statsResolution = ""
    m.statsBitrate = invalid
    m.statsFps = ""

    ' Skip seek debouncing - accumulate rapid button presses
    m.pendingSkipSeconds = 0
    m.skipSeekTimer = m.top.findNode("SkipSeekTimer")

    m.top.notificationInterval = 1

    ' asyncStopSemantics available since Roku OS 12.5
    if m.top.hasField("asyncStopSemantics")
        m.top.asyncStopSemantics = true
    end if

    #if DEBUG_LOG_VIDEO_QUALITY
        m.top.addFields({
            "_resolution": ""
            "_audioFormat": ""
            "_videoFormat": ""
        })

        m.top.observeField("streamingSegment", FuncName(OnStreamingSegmentChangeDebug))
        m.top.observeField("audioFormat", FuncName(OnFormatChangeDebug))
        m.top.observeField("videoFormat", FuncName(OnFormatChangeDebug))
        m.top.observeField("_audioFormat", FuncName(OnQualityChangeDebug))
        m.top.observeField("_videoFormat", FuncName(OnQualityChangeDebug))
    #end if
end function

#if DEBUG_LOG_VIDEO_QUALITY
    function OnStreamingSegmentChangeDebug()
        segment = m.top.streamingSegment
        width = segment.width
        height = segment.height
        if width > 0 and height > 0
            m.top._resolution = `${width}x${height}`
        end if
    end function

    function OnFormatChangeDebug()
        audioFormat = m.top.audioFormat
        videoFormat = m.top.videoFormat
        resolution = m.top._resolution

        m.top._audioFormat = audioFormat
        m.top._videoFormat = `${videoFormat} ${resolution}`
    end function

    function OnQualityChangeDebug()
        LogDebug("Video format:", m.top._videoFormat, "Audio format:", m.top._audioFormat)
    end function
#end if

function OnNodeReady()
    InitializePictureInPicture()

    DisposableObserveFieldScoped(m.videoQueue, "hasPrevious", FuncName(OnHasPreviousChange))
    DisposableObserveFieldScoped(m.videoQueue, "hasNext", FuncName(OnHasNextChange))
    OnHasPreviousChange()
    OnHasNextChange()

    ' Center playback buttons
    DisposableObserveFieldScoped(m.previousButton, "buttonSelected", FuncName(OnPreviousButtonSelected))
    DisposableObserveFieldScoped(m.skipBackButton, "buttonSelected", FuncName(OnSkipBackButtonSelected))
    DisposableObserveFieldScoped(m.playButton, "buttonSelected", FuncName(OnPlayButtonSelected))
    DisposableObserveFieldScoped(m.skipForwardButton, "buttonSelected", FuncName(OnSkipForwardButtonSelected))
    DisposableObserveFieldScoped(m.nextButton, "buttonSelected", FuncName(OnNextButtonSelected))

    ' Right feature buttons
    DisposableObserveFieldScoped(m.qualityButton, "buttonSelected", FuncName(OnQualityButtonSelected))
    DisposableObserveFieldScoped(m.ccButton, "buttonSelected", FuncName(OnCCButtonSelected))
    DisposableObserveFieldScoped(m.statsButton, "buttonSelected", FuncName(OnStatsButtonSelected))
    DisposableObserveFieldScoped(m.bookmarkButton, "buttonSelected", FuncName(OnBookmarkButtonSelected))
    DisposableObserveFieldScoped(m.minimizeButton, "buttonSelected", FuncName(OnMinimizeButtonSelected))

    DisposableObserveField(m.top, "state", FuncName(OnVideoPlayerStateChange))
    DisposableObserveField(m.top, "bufferingStatus", FuncName(OnBufferingStatusChange))

    DisposableObserveField(m.progressTimer, "fire", FuncName(OnProgress))
    DisposableObserveField(m.skipSeekTimer, "fire", FuncName(OnSkipSeekTimer))

    SetupNavigation()
    SetupStatsOverlay()
    SetupQualityButton()
    SponsorBlock.SetupSponsorBlock()

    if m.top.hasFocus() and m.videoUi.visible and m.videoUi.opacity = 1
        NodeSetFocus(m.playButton, true)
    end if
end function

function SetupNavigation()
    ' Linear navigation through all buttons (left to right):
    ' PreviousButton <-> SkipBackButton <-> PlayButton <-> SkipForwardButton <-> NextButton <->
    ' QualityButton <-> CCButton <-> StatsButton <-> BookmarkButton <-> MinimizeButton

    ' Center playback buttons
    SetNavigation(m.previousButton, RemoteKeys.Right, m.skipBackButton)
    SetNavigation(m.previousButton, RemoteKeys.Right, m.playButton) ' fallback

    SetNavigation(m.skipBackButton, RemoteKeys.Left, m.previousButton)
    SetNavigation(m.skipBackButton, RemoteKeys.Right, m.playButton)

    SetNavigation(m.playButton, RemoteKeys.Left, m.skipBackButton)
    SetNavigation(m.playButton, RemoteKeys.Left, m.previousButton) ' fallback
    SetNavigation(m.playButton, RemoteKeys.Right, m.skipForwardButton)

    SetNavigation(m.skipForwardButton, RemoteKeys.Left, m.playButton)
    SetNavigation(m.skipForwardButton, RemoteKeys.Right, m.nextButton)
    SetNavigation(m.skipForwardButton, RemoteKeys.Right, m.qualityButton) ' fallback
    SetNavigation(m.skipForwardButton, RemoteKeys.Right, m.ccButton) ' fallback

    SetNavigation(m.nextButton, RemoteKeys.Left, m.skipForwardButton)
    SetNavigation(m.nextButton, RemoteKeys.Left, m.playButton) ' fallback
    SetNavigation(m.nextButton, RemoteKeys.Right, m.qualityButton)
    SetNavigation(m.nextButton, RemoteKeys.Right, m.ccButton) ' fallback

    ' Right feature buttons
    SetNavigation(m.qualityButton, RemoteKeys.Left, m.nextButton)
    SetNavigation(m.qualityButton, RemoteKeys.Left, m.skipForwardButton) ' fallback
    SetNavigation(m.qualityButton, RemoteKeys.Right, m.ccButton)

    SetNavigation(m.ccButton, RemoteKeys.Left, m.qualityButton)
    SetNavigation(m.ccButton, RemoteKeys.Left, m.nextButton) ' fallback
    SetNavigation(m.ccButton, RemoteKeys.Left, m.skipForwardButton) ' fallback
    SetNavigation(m.ccButton, RemoteKeys.Right, m.statsButton)
    SetNavigation(m.ccButton, RemoteKeys.Right, m.bookmarkButton) ' fallback

    SetNavigation(m.statsButton, RemoteKeys.Left, m.ccButton)
    SetNavigation(m.statsButton, RemoteKeys.Left, m.qualityButton) ' fallback
    SetNavigation(m.statsButton, RemoteKeys.Right, m.bookmarkButton)
    SetNavigation(m.statsButton, RemoteKeys.Right, m.minimizeButton) ' fallback

    SetNavigation(m.bookmarkButton, RemoteKeys.Left, m.statsButton)
    SetNavigation(m.bookmarkButton, RemoteKeys.Left, m.ccButton) ' fallback
    SetNavigation(m.bookmarkButton, RemoteKeys.Right, m.minimizeButton)

    SetNavigation(m.minimizeButton, RemoteKeys.Left, m.bookmarkButton)
    SetNavigation(m.minimizeButton, RemoteKeys.Left, m.statsButton) ' fallback
end function

function SetupQualityButton() as void
    if m.qualityButton = invalid
        return
    end if

    m.qualityButton.disabled = (m.top.preferences = invalid)

    if m.top.preferences <> invalid
        DisposableObserveFieldScoped(m.top.preferences, "playback.preferred_quality", FuncName(OnPreferredQualityChange))
    end if

    OnPreferredQualityChange()
end function

function OnPreferredQualityChange() as void
    if m.qualityButton = invalid
        return
    end if

    value = ""
    if m.top.preferences <> invalid
        value = ValidString(m.top.preferences["playback.preferred_quality"])
    end if

    m.qualityButton.text = FormatQualityButtonLabel(value)
end function

function FormatQualityButtonLabel(value as string) as string
    if StringUtils.IsNullOrEmpty(value) or value = "auto"
        return Tr(Locale.Settings.AutoQuality)
    end if

    if value.InStr(",") <> -1
        value = value.Split(",")[0].Trim()
    end if

    ' Remove the "p" suffix for compact display (e.g., "1080p" -> "1080")
    if value.EndsWith("p")
        value = value.Left(value.Len() - 1)
    end if

    return value
end function

function PlayWithContent(contentNode as object)
    videoContentNode = CreateObject("roSGNode", "ContentNode")

    if not StringUtils.IsNullOrEmpty(contentNode.videoId)
        videoContentNode.AddFields({ videoId: contentNode.videoId })
    end if
    if ValidInt(contentNode.timestamp) <> -1
        videoContentNode.AddFields({ timestamp: contentNode.timestamp })
    else if contentNode.percentDurationWatched > 0 and contentNode.percentDurationWatched < 100
        videoContentNode.AddFields({ percentDurationWatched: contentNode.percentDurationWatched })
    end if
    if not StringUtils.IsNullOrEmpty(contentNode.title)
        videoContentNode.title = contentNode.title
    end if
    ' NOTE: "_author" not "author". See PlaylistContentNode.xml for explanation.
    author = contentNode._author
    if StringUtils.IsNullOrEmpty(author)
        lines = contentNode.lines
        if IsArray(lines) and lines.Count() > 0
            author = lines[0]
        end if
    end if
    if not StringUtils.IsNullOrEmpty(author)
        videoContentNode.secondaryTitle = author
    end if
    metadata = contentNode.metadata
    if IsAssociativeArray(metadata)
        videoContentNode.AddFields({ metadata: metadata })
    end if

    ' Update UI labels immediately with available info
    m.titleLabel.text = videoContentNode.title
    m.secondaryTitleLabel.text = videoContentNode.secondaryTitle
    if m.viewCountLabel <> invalid
        m.viewCountLabel.text = ""
    end if

    StartVideoContentJob(videoContentNode)
    Lounge.SendNowPlayingLoading(contentNode.videoId)
end function

function StartVideoContentJob(videoContentNode as object)
    if m.videoContentJob <> invalid
        m.videoContentJob.cancel = true
    end if

    m.top.content = videoContentNode

    input = {
        content: videoContentNode
        invidious: m.top.invidious
        innertube: m.top.innertube
        preferences: m.top.preferences
        loungeService: m.top.loungeService
        playletServerPort: m.top.webServer.port
    }

    m.videoContentJob = JobSystem.CreateCallback(OnVideoContentJobDone)
    JobSystem.QueueJob(m.jobQueue, Jobs.VideoContentJob, input, m.videoContentJob)
end function

function OnVideoContentJobDone(event as object) as void
    JobSystem.UnobserveCallback(event.getRoSGNode())
    m.videoContentJob = invalid

    info = event.getInfo()
    if info.cancel or m.onCloseCalled = true
        return
    end if

    content = m.top.content

    if not info.success
        videoId = ""
        if content <> invalid
            videoId = content.videoId
        end if

        title = Tr(Locale.VideoPlayer.VideoLoadError)
        message = Tr(Locale.VideoPlayer.VideoLoadErrorMessage).Replace("%1", videoId) + `\n${info.error}`
        buttons = [Tr(Locale.Buttons.PlayNextVideo), Tr(Locale.Buttons.Cancel)]

        dialog = DialogUtils.ShowTimedDialogButtons(message, title, buttons, 0, 10, true)
        if dialog <> invalid
            dialog.observeFieldScoped("wasClosed", FuncName(OnVideoContentJobErrorDialogResponse))
        else
            OnVideoContentJobErrorDialogResponse(invalid)
        end if

        Lounge.SendOnStateChange()
        return
    end if

    ' Update UI with metadata
    UpdateUiFromMetadata(content)

    metadata = content.metadata
    SponsorBlock.FetchSponsorBlock(metadata)

    SeekToInitialPosition(content)

    PlayAfterPreviousPlayerHasStopped()
    MarkVideoWatched(content.videoId, metadata.playbackTrackingUrls)
end function

function UpdateUiFromMetadata(content as object) as void
    if content = invalid
        return
    end if

    m.titleLabel.text = ValidString(content.title)
    m.secondaryTitleLabel.text = ValidString(content.secondaryTitle)

    metadata = content.metadata
    if IsAssociativeArray(metadata)
        ' Set view count and publish date
        viewCountText = ""
        viewCount = InvidiousContent.VideoGetViewCountText(metadata)
        if not StringUtils.IsNullOrEmpty(viewCount)
            viewCountText = viewCount
        end if
        publishedText = InvidiousContent.VideoGetPublishedText(metadata)
        if not StringUtils.IsNullOrEmpty(publishedText)
            if viewCountText.Len() > 0
                viewCountText = `${viewCountText} â€¢ ${publishedText}`
            else
                viewCountText = publishedText
            end if
        end if
        if m.viewCountLabel <> invalid
            m.viewCountLabel.text = viewCountText
        end if

        ' Set background poster
        if m.backgroundPoster <> invalid and not StringUtils.IsNullOrEmpty(content.videoId)
            service = new Invidious.InvidiousService(m.top.invidious)
            instance = service.GetInstance()
            m.backgroundPoster.uri = `${instance}/vi/${content.videoId}/maxresdefault.jpg`
        end if
    end if
end function

function SeekToInitialPosition(content as object) as void
    if content = invalid
        return
    end if

    if content.Live = true
        LogInfo("Seeking to edge of live stream")
        m.top.seek = 999999
        return
    end if

    timestamp = ValidInt(content.timestamp)
    if timestamp > 0
        LogInfo("Seeking to timestamp:", timestamp)
        m.top.seek = content.timestamp
        return
    end if

    percentDurationWatched = ValidFloat(content.percentDurationWatched)
    if percentDurationWatched > 0
        m.seekToPercent = percentDurationWatched
        SeekToPercentOfDuration()
    end if
end function

function SeekToPercentOfDuration() as void
    m.top.UnobserveField("duration")

    seekToPercent = m.seekToPercent
    if seekToPercent = invalid
        return
    end if

    duration = m.top.duration
    if duration = 0
        m.top.ObserveField("duration", FuncName(SeekToPercentOfDuration))
        return
    end if

    if duration < 30
        return
    end if

    m.seekToPercent = invalid
    seek = (MathUtils.Clamp(seekToPercent, 0, 100) / 100.0) * duration
    if seek > 0
        LogInfo("Seeking to percent duration watched", seek)
        m.top.seek = seek
    end if
end function

function PlayAfterPreviousPlayerHasStopped() as void
    previousPlayer = m.top.previousPlayer
    m.top.previousPlayer = invalid

    if previousPlayer = invalid
        m.top.control = "play"
        return
    end if

    previousPlayerState = previousPlayer.state
    LogInfo("Previous player state:", previousPlayerState)

    if previousPlayerState = "stopping"
        previousPlayer.observeFieldScoped("state", FuncName(OnPreviousPlayerState))
        return
    end if

    m.top.control = "play"
end function

function OnPreviousPlayerState(event as object) as void
    previousPlayer = event.getRoSGNode()

    if m.onCloseCalled = true
        previousPlayer.unobserveFieldScoped("state")
        return
    end if

    previousPlayerState = previousPlayer.state
    LogInfo("Previous player state change:", previousPlayerState)

    if previousPlayerState = "stopped" or previousPlayerState = "error" or previousPlayerState = "finished" or previousPlayerState = "none"
        previousPlayer.unobserveFieldScoped("state")
        m.top.control = "play"
    end if
end function

function OnVideoContentJobErrorDialogResponse(event as object)
    shouldPlayNext = false
    if event <> invalid
        dialog = event.getRoSGNode()
        dialog.unobserveFieldScoped("wasClosed")
        shouldPlayNext = dialog.actualButtonSelected = 0
    end if

    if not shouldPlayNext or not VideoQueueUtils.PlayNext(m.videoQueue, m.invidious, m.preferences)
        if m.top.isSameNode(m.videoQueue.player)
            m.videoQueue.closePlayer = true
        end if
    end if

    Lounge.SendOnStateChange()
end function

function MarkVideoWatched(videoId as dynamic, playbackTrackingUrls as dynamic) as void
    if StringUtils.IsNullOrEmpty(videoId)
        return
    end if

    invidiousNode = m.top.invidious
    authToken = invidiousNode.authToken
    if authToken = invalid
        return
    end if

    if m.markVideoWatchedJob <> invalid
        m.markVideoWatchedJob.cancel = true
    end if

    profileType = authToken.profileNode.type

    input = {
        videoId: videoId
        invidious: invidiousNode
        authToken: authToken
        profileType: profileType
        playbackTrackingUrls: playbackTrackingUrls
    }

    m.markVideoWatchedJob = JobSystem.CreateCallback()
    m.markVideoWatchedJob.addField("watchTime", "float", false)
    JobSystem.QueueJob(m.jobQueue, Jobs.MarkVideoWatchedJob, input, m.markVideoWatchedJob)

    if profileType <> "youtube"
        return
    end if

    m.watchTimeMarker = -1
    m.top.ObserveFieldScoped("position", FuncName(OnPositionChangeMarkWatchTime))
end function

function OnPositionChangeMarkWatchTime(event as object) as void
    if m.markVideoWatchedJob = invalid
        return
    end if

    currentPosition = event.getData()
    currentWatchTimeMarker = m.watchTimeMarker
    m.watchTimeMarker = (currentPosition \ 20) * 20
    if currentWatchTimeMarker = currentPosition
        return
    end if
    m.markVideoWatchedJob.watchTime = m.watchTimeMarker
end function

function OnClose()
    m.onCloseCalled = true
    m.top.previousPlayer = invalid

    if m.markVideoWatchedJob <> invalid
        m.markVideoWatchedJob.cancel = true
        m.markVideoWatchedJob = invalid
    end if
    if m.videoContentJob <> invalid
        m.videoContentJob.cancel = true
        m.videoContentJob = invalid
    end if
    if m.sponsorBlockSegmentsJob <> invalid
        m.sponsorBlockSegmentsJob.cancel = true
        m.sponsorBlockSegmentsJob = invalid
    end if

    parent = m.top.getParent()
    if parent <> invalid
        parent.RemoveChild(m.top)
    end if
    SponsorBlock.RemoveNotifcation(m.notifications)

    try
        m.top.control = "stop"
    catch error
        errorMessage = ErrorUtils.Format(error)
        LogError("Error stopping video:", errorMessage)
        DialogUtils.ShowDialogEx({
            message: errorMessage
            title: Tr(Locale.VideoPlayer.ErrorClosingVideo)
            large: true
        })
    end try

    m.top.content = invalid
    m.top.dispose = true
end function

function OnVideoPlayerStateChange() as void
    Lounge.SendOnStateChange()

    state = m.top.state
    content = m.top.content

    if state = "playing"
        m.isSeekingPosition = false
    end if

    if state = "playing" and not m.videoPlayingSuccess
        LogInfo(`Now playing video ${content.url}`)
        m.videoPlayingSuccess = true
    end if

    ' Update play button state
    if state = "playing"
        m.playButton.toggleState = false ' Pause icon
        m.playButton.disabled = false
        m.progressTimer.control = "start"
    else if state = "paused"
        m.playButton.toggleState = true ' Play icon
        m.playButton.disabled = false
    else
        m.playButton.disabled = true
    end if

    ' Handle buffering UI
    if state = "buffering"
        m.loadingLabel.text = Tr(Locale.VideoPlayer.Buffering)
        m.loadingSpinner.control = "start"
        m.loadingUi.visible = true
        m.backgroundPoster.visible = true
        m.backgroundPosterSmall.visible = true
    else
        m.loadingSpinner.control = "stop"
        m.loadingUi.visible = false
        m.backgroundPoster.visible = false
        m.backgroundPosterSmall.visible = false
    end if

    if state = "stopping" or state = "stopped"
        m.videoUi.visible = false
        return
    end if

    ' Error handling with retry logic
    errorData = invalid
    if state = "error"
        errorInfo = m.top.errorInfo
        errorData = GetPlayerErrorData(content.videoId, errorInfo)

        LogErrorNoTelemetry(errorData.title, errorData.body)

        if m.videoPlayingSuccess <> true
            if errorInfo.category = "http" or errorInfo.category = "mediaerror"
                playletStreamUrls = content.playletStreamUrls
                currentUrlIndex = content.playletStreamUrlIndex
                nextUrlIndex = currentUrlIndex + 1
                content.playletStreamUrlIndex = nextUrlIndex
                if nextUrlIndex < playletStreamUrls.Count()
                    currentUrl = content.url
                    nextUrl = playletStreamUrls[nextUrlIndex]

                    if StringUtils.IsNullOrEmpty(nextUrl)
                        LogError("Next stream URL is empty, cannot try next stream")
                    end if

                    content.url = nextUrl
                    SeekToInitialPosition(content)

                    m.ignoreNextFinishedState = true
                    m.top.control = "play"

                    timestamp = content.timestamp
                    hasTimestamp = IsInt(timestamp)

                    if hasTimestamp and timestamp > 0
                        m.top.seek = content.timestamp
                    end if

                    msg = `Stream ${currentUrl} failed to play. Trying next stream ${nextUrl}`
                    LogErrorNoTelemetry(msg)

                    errorData.title = msg + `\n` + errorData.title
                    ReportVideoError(errorData, currentUrl, playletStreamUrls, currentUrlIndex, false)
                    return
                end if
            end if
        end if
    end if

    if state = "finished" and m.ignoreNextFinishedState = true
        m.ignoreNextFinishedState = false
        return
    end if

    if state = "finished"
        OnVideoFinished()
        return
    end if

    if state = "error"
        LogErrorNoTelemetry(errorData.title, errorData.body)
        ReportVideoError(errorData, content.url, content.playletStreamUrls, content.playletStreamUrlIndex, true)

        buttons = [Tr(Locale.Buttons.PlayNextVideo), Tr(Locale.Buttons.Cancel)]

        dialog = DialogUtils.ShowTimedDialogButtons(errorData.body, errorData.title, buttons, 0, 10, true)
        if dialog <> invalid
            dialog.observeFieldScoped("wasClosed", FuncName(OnVideoContentJobErrorDialogResponse))
        else
            OnVideoContentJobErrorDialogResponse(invalid)
        end if
        m.ignoreNextFinishedState = true
    end if
end function

function GetPlayerErrorData(videoId as string, errorInfo as object) as object
    if errorInfo = invalid
        return invalid
    end if

    errorMsg = m.top.errorMsg
    errorCode = m.top.errorCode
    errorStr = m.top.errorStr

    title = Tr(Locale.VideoPlayer.ErrorPlayingVideo).Replace("%1", videoId)
    body = `errorMsg: ${errorMsg}\nerrorCode: ${errorCode}\nerrorStr: ${errorStr}`
    for each key in errorInfo
        body += `\n${key}: ${errorInfo[key]}`
    end for

    fingerprint = [
        Locale.VideoPlayer.ErrorPlayingVideo
        errorMsg
        errorCode
        errorInfo.source
        errorInfo.ignored
        errorInfo.category
        errorInfo.errcode
        errorInfo.drmerrcode
    ]

    return {
        title: title
        body: body
        fingerprint: fingerprint
    }
end function

function ReportVideoError(errorData as object, url as dynamic, urls as object, urlIndex as dynamic, shownInDialog as boolean) as void
    attachments = invalid
    if errorData.body.Instr("malformed data") <> -1 or errorData.body.Instr("invalid pathname") <> -1
        lastGeneratedDash = ValidString(ReadAsciiFile("cachefs:/last_generated_dash.xml"))
        lastGeneratedHls = ValidString(ReadAsciiFile("cachefs:/last_generated_hls.m3u8"))
        lastPlayerResponse = ValidString(ReadAsciiFile("cachefs:/last_player_response.json"))

        attachments = [{
            filename: "last_generated_dash.xml"
            content_type: "plain/text"
            data: lastGeneratedDash
        }, {
            filename: "last_generated_hls.m3u8"
            content_type: "plain/text"
            data: lastGeneratedHls
        }, {
            filename: "last_player_response.json"
            content_type: "application/json"
            data: lastPlayerResponse
        }]
    end if

    position = m.top.position
    duration = m.top.duration
    message = [
        errorData.title
        errorData.body
        `Dialog shown: ${shownInDialog}`
        `Position: ${position}`
        `Duration: ${duration}`
        `Url: ${url}`
        `Urls: ` + ToString(urls)
        `Url index: ${urlIndex}`
    ].Join(`\n`)

    errorData.fingerprint.push(shownInDialog)

    if shownInDialog
        level = "error"
    else
        level = "warning"
    end if

    LogTelemetryEvent({
        level: level
        message: message
        fingerprint: errorData.fingerprint
        attachments: attachments
    })
end function

function OnVideoFinished() as void
    if not VideoQueueUtils.PlayNext(m.videoQueue, m.invidious, m.preferences)
        m.videoQueue.closePlayer = true
    end if
end function

function OnBufferingStatusChange() as void
    bufferingStatus = m.top.bufferingStatus
    if bufferingStatus = invalid
        return
    end if

    m.loadingPercentLabel.text = `${bufferingStatus.percentage}%`
end function

function IsLiveVideo() as boolean
    content = m.top.content
    return content <> invalid and content.Live = true
end function

function OnKeyEvent(key as string, press as boolean) as boolean
    if press = false
        return false
    end if

    state = m.top.state
    uiState = m.top.playerUiState

    if key = RemoteKeys.Play
        if state = "paused" and uiState = PlayerUiState.Hidden
            return false
        end if
    end if

    if key = RemoteKeys.Play or key = RemoteKeys.PlayOnly
        if state = "playing" and uiState = PlayerUiState.Hidden
            m.top.playerUiState = PlayerUiState.FadingIn
            return false
        end if
    end if

    if uiState = PlayerUiState.Visible
        StartHideVideoUiTimer()
    end if

    if uiState = PlayerUiState.Hidden or uiState = PlayerUiState.FadingOut
        m.top.playerUiState = PlayerUiState.FadingIn
    end if

    if NavigationKeyHandler(key, press).handled
        return true
    end if

    if key = RemoteKeys.Back
        m.videoQueue.closePlayer = true
        return true
    end if

    ' Remote skip buttons (rewind/fast forward)
    if key = RemoteKeys.Rewind
        OnSkipBackButtonSelected()
        return true
    end if

    if key = RemoteKeys.FastForward
        OnSkipForwardButtonSelected()
        return true
    end if

    if key = RemoteKeys.Left or key = RemoteKeys.Right
        m.isSeekingPosition = true
    end if

    return false
end function

' Deprecated - kept for compatibility with old preferences
function OnShowFullScreenHint() as void
end function

function OnHasPreviousChange()
    m.previousButton.disabled = not m.videoQueue.hasPrevious
end function

function OnHasNextChange()
    m.nextButton.disabled = not m.videoQueue.hasNext
end function

' Skip button handlers (10 second skip with debouncing)
function OnSkipBackButtonSelected()
    StartHideVideoUiTimer()
    AccumulateSkip(-SKIP_SECONDS)
end function

function OnSkipForwardButtonSelected()
    StartHideVideoUiTimer()
    AccumulateSkip(SKIP_SECONDS)
end function

function AccumulateSkip(seconds as integer) as void
    m.pendingSkipSeconds += seconds
    UpdatePendingSkipPosition()

    m.skipSeekTimer.control = "stop"
    m.skipSeekTimer.control = "start"
end function

function UpdatePendingSkipPosition() as void
    if m.pendingSkipSeconds = 0
        return
    end if

    currentPosition = m.top.position
    duration = m.top.duration
    pendingPosition = currentPosition + m.pendingSkipSeconds

    if pendingPosition < 0
        pendingPosition = 0
    end if
    if duration > 0 and pendingPosition > duration
        pendingPosition = duration
    end if

    m.trickPlayBar.position = pendingPosition
    if duration > 0
        m.trickPlayBar.progress = pendingPosition / duration
    end if
end function

function OnSkipSeekTimer() as void
    if m.pendingSkipSeconds = 0
        return
    end if

    currentPosition = m.top.position
    duration = m.top.duration
    newPosition = currentPosition + m.pendingSkipSeconds

    if newPosition < 0
        newPosition = 0
    end if
    if duration > 0 and newPosition > duration
        newPosition = duration
    end if

    m.pendingSkipSeconds = 0
    m.top.seek = newPosition
end function

function OnPlayButtonSelected()
    StartHideVideoUiTimer()
    state = m.top.state
    if state = "playing"
        m.top.control = "pause"
    else if state = "paused"
        m.top.control = "resume"
    end if
end function

function OnPreviousButtonSelected()
    StartHideVideoUiTimer()
    m.videoQueue.previous = true
end function

function OnNextButtonSelected()
    StartHideVideoUiTimer()
    m.videoQueue.next = true
end function

function OnQualityButtonSelected() as void
    StartHideVideoUiTimer()
    if m.top.preferences = invalid
        LogWarn("Cannot change quality: preferences node is invalid")
        return
    end if

    qualityOptions = ["auto", "1080p", "720p", "480p", "360p", "240p", "144p"]

    currentValue = ValidString(m.top.preferences["playback.preferred_quality"])
    if StringUtils.IsNullOrEmpty(currentValue)
        currentValue = "auto"
    end if

    if currentValue.InStr(",") <> -1
        currentValue = currentValue.Split(",")[0].Trim()
    end if

    currentIndex = 0
    for i = 0 to qualityOptions.Count() - 1
        if LCase(qualityOptions[i]) = LCase(currentValue)
            currentIndex = i
            exit for
        end if
    end for

    nextIndex = (currentIndex + 1) mod qualityOptions.Count()
    newValue = qualityOptions[nextIndex]

    m.top.preferences["playback.preferred_quality"] = newValue
    LogInfo("Quality changed to:", newValue)
end function

function OnCCButtonSelected()
    StartHideVideoUiTimer()
    m.ccEnabled = not m.ccEnabled
    m.ccButton.active = m.ccEnabled

    if m.top.hasField("globalCaptionMode")
        if m.ccEnabled
            m.top.globalCaptionMode = "On"
        else
            m.top.globalCaptionMode = "Off"
        end if
    else
        LogWarn("globalCaptionMode is not supported; CC toggle is best-effort")
    end if

    LogInfo("Closed captions toggled:", m.ccEnabled)
end function

function OnStatsButtonSelected() as void
    StartHideVideoUiTimer()
    prefs = m.top.preferences
    if prefs = invalid
        LogWarn("Cannot toggle stats overlay: preferences node is invalid")
        return
    end if

    enabled = prefs["playback.stats_for_nerds"] = true
    prefs["playback.stats_for_nerds"] = not enabled
end function

function OnBookmarkButtonSelected() as void
    StartHideVideoUiTimer()
    content = m.top.content
    if content = invalid
        LogWarn("Cannot add bookmark: content is invalid")
        return
    end if

    videoId = content.videoId
    if StringUtils.IsNullOrEmpty(videoId)
        LogWarn("Cannot add bookmark: videoId is empty")
        return
    end if

    bookmarksService = m.top.bookmarksService
    if bookmarksService = invalid
        LogWarn("Cannot add bookmark: bookmarksService is invalid")
        return
    end if

    bookmark = bookmarksService.content.findNode(videoId)
    if bookmark <> invalid
        bookmarksService@.RemoveBookmark(videoId)
        LogInfo("Removed video from bookmarks:", videoId)
    else
        group = Tr(Locale.Feed.Videos)
        bookmarksService@.AddVideoBookmark(videoId, group)
        LogInfo("Added video to bookmarks:", videoId)
    end if
end function

function OnMinimizeButtonSelected()
    StartHideVideoUiTimer()
    VideoQueueUtils.ToggleVideoPictureInPicture(m.videoQueue)
end function

function OnProgress() as void
    if m.pendingSkipSeconds <> 0
        return
    end if

    duration = m.top.duration
    position = m.top.position

    m.trickPlayBar.position = position
    m.trickPlayBar.duration = duration

    if duration = 0
        m.trickPlayBar.progress = 0
        return
    end if

    m.trickPlayBar.progress = position / duration
end function

function SetupStatsOverlay() as void
    m.statsOverlay = m.top.findNode("StatsOverlay")
    m.statsOverlayLabel = m.top.findNode("StatsOverlayLabel")
    m.statsOverlayTimer = m.top.findNode("StatsOverlayTimer")

    if m.statsOverlayTimer <> invalid
        DisposableObserveField(m.statsOverlayTimer, "fire", FuncName(OnStatsOverlayTimer))
    end if

    DisposableObserveField(m.top, "streamingSegment", FuncName(OnStreamingSegmentChangeStats))
    DisposableObserveField(m.top, "audioFormat", FuncName(UpdateStatsOverlay))
    DisposableObserveField(m.top, "videoFormat", FuncName(UpdateStatsOverlay))

    if m.top.preferences <> invalid
        DisposableObserveFieldScoped(m.top.preferences, "playback.stats_for_nerds", FuncName(OnStatsPreferenceChange))
    end if

    OnStatsPreferenceChange()
end function

function OnStatsPreferenceChange() as void
    enabled = false
    if m.top.preferences <> invalid
        enabled = m.top.preferences["playback.stats_for_nerds"] = true
    end if

    m.statsOverlayEnabled = enabled

    if m.statsButton <> invalid
        m.statsButton.active = enabled
    end if

    UpdateStatsOverlayVisibility()
end function

function UpdateStatsOverlayVisibility() as void
    if m.statsOverlay = invalid
        return
    end if

    visible = m.statsOverlayEnabled
    if m.container <> invalid and not m.container.fullscreen
        visible = false
    end if

    m.statsOverlay.visible = visible
    if m.statsOverlayTimer <> invalid
        if visible
            m.statsOverlayTimer.control = "start"
        else
            m.statsOverlayTimer.control = "stop"
        end if
    end if

    if visible
        UpdateStatsOverlay()
    end if
end function

function OnStatsOverlayTimer() as void
    UpdateStatsOverlay()
end function

function OnStreamingSegmentChangeStats() as void
    segment = m.top.streamingSegment
    if not IsAssociativeArray(segment)
        return
    end if

    m.statsBitrate = invalid

    width = segment.width
    height = segment.height
    if width > 0 and height > 0
        m.statsResolution = `${width}x${height}`
    end if

    if segment.DoesExist("fps")
        m.statsFps = ToString(segment.fps)
    else if segment.DoesExist("frameRate")
        m.statsFps = ToString(segment.frameRate)
    end if

    bitrate = ExtractSegmentBitrate(segment)
    if bitrate <> invalid
        m.statsBitrate = bitrate
    else
        inferred = InferBitrateFromMetadata()
        if inferred <> invalid
            m.statsBitrate = inferred
        end if
    end if

    UpdateStatsOverlay()
end function

function UpdateStatsOverlay() as void
    if m.statsOverlay = invalid or not m.statsOverlay.visible or m.statsOverlayLabel = invalid
        return
    end if

    lines = []

    state = ValidString(m.top.state)
    if not StringUtils.IsNullOrEmpty(state)
        lines.Push(`State: ${state}`)
    end if

    url = ""
    if m.top.content <> invalid
        url = ValidString(m.top.content.url)
    end if

    query = ParseUrlQuery(url)
    containerParam = ExtractQueryValue(query, "container")
    if not StringUtils.IsNullOrEmpty(containerParam)
        container = containerParam
    else
        container = InferContainerFromUrl(url)
    end if
    if not StringUtils.IsNullOrEmpty(container)
        lines.Push(`Container: ${container}`)
    end if

    quality = ExtractQueryValue(query, "quality")
    if not StringUtils.IsNullOrEmpty(quality)
        if quality.InStr(",") <> -1
            quality = quality.Split(",")[0].Trim()
        end if
        lines.Push(`Quality: ${quality}`)
        if StringUtils.IsNullOrEmpty(m.statsResolution)
            m.statsResolution = quality
        end if
    end if

    videoFormat = ValidString(m.top.videoFormat)
    if not StringUtils.IsNullOrEmpty(videoFormat)
        lines.Push(`Video format: ${videoFormat}`)
        parsedVideo = ParseMimeType(videoFormat)
        if not StringUtils.IsNullOrEmpty(parsedVideo.codec)
            lines.Push(`Video codec: ${parsedVideo.codec}`)
        end if
    end if

    audioFormat = ValidString(m.top.audioFormat)
    if not StringUtils.IsNullOrEmpty(audioFormat)
        lines.Push(`Audio format: ${audioFormat}`)
        parsedAudio = ParseMimeType(audioFormat)
        if not StringUtils.IsNullOrEmpty(parsedAudio.codec)
            lines.Push(`Audio codec: ${parsedAudio.codec}`)
        end if
    end if

    resolution = m.statsResolution
    if not StringUtils.IsNullOrEmpty(resolution)
        resLine = `Resolution: ${resolution}`
        if not StringUtils.IsNullOrEmpty(m.statsFps)
            resLine = resLine + ` @${m.statsFps}fps`
        end if
        lines.Push(resLine)
    end if

    if m.statsBitrate = invalid
        inferred = InferBitrateFromMetadata()
        if inferred <> invalid
            m.statsBitrate = inferred
        end if
    end if

    bitrate = FormatBitrate(m.statsBitrate)
    if not StringUtils.IsNullOrEmpty(bitrate)
        lines.Push(`Bitrate: ${bitrate}`)
    end if

    positionText = FormatTime(m.top.position)
    durationText = FormatTime(m.top.duration)
    if not StringUtils.IsNullOrEmpty(positionText) or not StringUtils.IsNullOrEmpty(durationText)
        lines.Push(`Position: ${positionText} / ${durationText}`)
    end if

    if not StringUtils.IsNullOrEmpty(url)
        lines.Push(`Source: ${TruncateString(url, 140)}`)
    end if

    if lines.Count() = 0
        lines.Push("Stats unavailable")
    end if

    m.statsOverlayLabel.text = lines.Join(`\n`)
end function

function InferContainerFromUrl(url as string) as string
    if StringUtils.IsNullOrEmpty(url)
        return ""
    end if

    lower = LCase(url)
    if lower.InStr(".mpd") <> -1 or lower.InStr("/dash") <> -1 or lower.InStr("/mux") <> -1
        return "dash"
    end if
    if lower.InStr(".m3u8") <> -1
        return "hls"
    end if
    if lower.InStr(".webm") <> -1
        return "webm"
    end if
    if lower.InStr(".mkv") <> -1
        return "mkv"
    end if
    if lower.InStr(".mp4") <> -1
        return "mp4"
    end if

    return ""
end function

function ParseUrlQuery(url as string) as object
    if StringUtils.IsNullOrEmpty(url)
        return {}
    end if
    if url.InStr("?") = -1
        return {}
    end if
    return UrlUtils.ParseQueryComponents(url)
end function

function ExtractQueryValue(query as object, key as string) as string
    if query = invalid or StringUtils.IsNullOrEmpty(key)
        return ""
    end if
    if not query.DoesExist(key)
        return ""
    end if

    value = query[key]
    if IsArray(value)
        if value.Count() = 0
            return ""
        end if
        value = value[0]
    end if

    return ValidString(value)
end function

function ParseMimeType(mimeType as string) as object
    result = { container: "", codec: "" }
    if StringUtils.IsNullOrEmpty(mimeType)
        return result
    end if

    parts = mimeType.Split(";")
    typePart = parts[0].Trim()
    slashIndex = typePart.InStr("/")
    if slashIndex <> -1
        result.container = typePart.Mid(slashIndex + 1)
    end if

    for each part in parts
        trimmed = part.Trim()
        if trimmed.StartsWith("codecs=")
            codecList = trimmed.Mid(7)
            codecList = codecList.Replace(chr(34), "")
            codecList = codecList.Replace("'", "")
            result.codec = codecList
            exit for
        end if
    end for

    return result
end function

function FormatBitrate(value as dynamic) as string
    bitrate = ParseNumeric(value)
    if bitrate = invalid or bitrate <= 0
        return ""
    end if

    kbps = bitrate \ 1000
    if kbps <= 0
        return `${bitrate} bps`
    end if
    return `${kbps} kbps`
end function

function FormatTime(value as dynamic) as string
    seconds = NormalizeSeconds(value)
    if seconds < 0
        return ""
    end if

    hours = seconds \ 3600
    minutes = (seconds mod 3600) \ 60
    secs = seconds mod 60

    if hours > 0
        return `${hours}:${Pad2(minutes)}:${Pad2(secs)}`
    end if
    return `${minutes}:${Pad2(secs)}`
end function

function Pad2(value as integer) as string
    if value < 10
        return "0" + value.ToStr()
    end if
    return value.ToStr()
end function

function TruncateString(value as string, maxLen as integer) as string
    if value.Len() <= maxLen
        return value
    end if
    return value.Left(maxLen) + "..."
end function

function NormalizeSeconds(value as dynamic) as integer
    if IsInt(value)
        return value
    end if
    if IsFloat(value)
        return CInt(value)
    end if
    if IsDouble(value)
        return CInt(value)
    end if
    if IsString(value)
        return CInt(Val(value))
    end if
    return -1
end function

function ParseNumeric(value as dynamic) as dynamic
    if IsInt(value)
        return value
    end if
    if IsFloat(value)
        return CInt(value)
    end if
    if IsDouble(value)
        return CInt(value)
    end if
    if IsString(value)
        parsed = Val(value)
        if parsed > 0
            return CInt(parsed)
        end if
    end if
    return invalid
end function

function ExtractSegmentBitrate(segment as object) as dynamic
    if segment = invalid
        return invalid
    end if

    keys = ["bitrate", "bandwidth", "bitsPerSecond", "bps"]
    for each key in keys
        if segment.DoesExist(key)
            value = ParseNumeric(segment[key])
            if value <> invalid
                return value
            end if
        end if
    end for

    return invalid
end function

function InferBitrateFromMetadata() as dynamic
    content = m.top.content
    if content = invalid
        return invalid
    end if

    metadata = content.metadata
    if not IsAssociativeArray(metadata)
        return invalid
    end if

    targetHeight = ParseResolutionHeight(m.statsResolution)
    if targetHeight <= 0
        return invalid
    end if

    bestBitrate = 0
    formats = ValidArray(metadata.adaptiveFormats)
    if formats.Count() = 0
        formats = ValidArray(metadata.formatStreams)
    end if

    for each fmt in formats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        height = ParseFormatHeight(fmt)
        if height <> targetHeight
            continue for
        end if

        bitrate = ParseNumeric(fmt["bitrate"])
        if bitrate <> invalid and bitrate > bestBitrate
            bestBitrate = bitrate
        end if
    end for

    if bestBitrate > 0
        return bestBitrate
    end if

    return invalid
end function

function ParseFormatHeight(fmt as object) as integer
    if fmt = invalid
        return 0
    end if

    heightValue = fmt["height"]
    if IsInt(heightValue)
        return heightValue
    end if
    if IsFloat(heightValue) or IsDouble(heightValue)
        return CInt(heightValue)
    end if

    size = ValidString(fmt["size"])
    if not StringUtils.IsNullOrEmpty(size)
        heightFromSize = ParseResolutionHeight(size)
        if heightFromSize > 0
            return heightFromSize
        end if
    end if

    resolution = ValidString(fmt["resolution"])
    if not StringUtils.IsNullOrEmpty(resolution)
        return ParseResolutionHeight(resolution)
    end if

    return 0
end function

function ParseResolutionHeight(value as string) as integer
    if StringUtils.IsNullOrEmpty(value)
        return 0
    end if

    lower = LCase(value)
    if lower.InStr("x") <> -1
        parts = lower.Split("x")
        if parts.Count() >= 2
            return CInt(Val(parts[1]))
        end if
    end if

    if lower.InStr("p") <> -1
        return CInt(Val(lower.Replace("p", "")))
    end if

    return CInt(Val(lower))
end function

function OnDispose()
    ShutDownPictureInPicture()
    ShutDownPlayerUi()
    DisposeObservers()
end function
