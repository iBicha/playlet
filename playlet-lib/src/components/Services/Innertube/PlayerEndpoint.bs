import "pkg:/components/Services/Innertube/Context.bs"
import "pkg:/components/Services/Innertube/NodesParser.bs"
import "pkg:/components/Services/Innertube/PoToken.bs"
import "pkg:/source/services/HttpClient.bs"
import "pkg:/source/utils/ObjectUtils.bs"
import "pkg:/source/utils/Types.bs"
import "pkg:/source/utils/UrlUtils.bs"

namespace Innertube

    function CreatePlayerRequest(videoId as string, client as Innertube.ClientType, options = invalid as object) as object
        visitorData = OptionUtils.Get(options, "visitorData")
        doSignatureTimestamp = ValidBool(OptionUtils.Get(options, "signatureTimestamp"))
        doPoToken = ValidBool(OptionUtils.Get(options, "poToken"))

        deviceInfo = CreateObject("roDeviceInfo")

        context = Innertube.CreateContext(client, deviceInfo, options)

        payload = {
            "videoId": videoId
            "context": context
            "playbackContext": {
                "contentPlaybackContext": {
                    "vis": 0
                    "splay": false
                    "referer": "https://www.youtube.com/watch?v=" + videoId
                    "currentUrl": "/watch?v=" + videoId
                    "autonavState": "STATE_ON"
                    "autoCaptionsDefaultOn": false
                    "html5Preference": "HTML5_PREF_WANTS"
                    "lactMilliseconds": "-1"
                    "isInlinePlaybackNoAd": true
                }
            }
            "attestationRequest": {
                "omitBotguardData": true
            }
            "racyCheckOk": true
            "contentCheckOk": true
        }

        sts = invalid
        if doSignatureTimestamp
            sts = GetSts()
            if sts <> invalid
                payload["playbackContext"]["contentPlaybackContext"]["signatureTimestamp"] = sts
            end if
        end if

        poToken = invalid
        if doPoToken
            poToken = Innertube.GetPoToken(visitorData, videoId)
            payload["serviceIntegrityDimensions"] = {
                "poToken": poToken
            }
        end if

        request = HttpClient.PostJson("https://www.youtube.com/youtubei/v1/player?prettyPrint=false&alt=json", payload)
        request.Headers(Innertube.CreateHeaders(client))
        if not StringUtils.IsNullOrEmpty(visitorData)
            request.Header("x-goog-visitor-id", visitorData)
        end if

        request.sts = sts
        request.poToken = poToken

        return request
    end function

    function ParseInnertubePlayerResponse(payload as object, sts as dynamic, poToken as dynamic) as object
        error = ParsePlayerResponseForError(payload)
        if error <> ""
            return {
                error: error
            }
        end if

        videoDetails = payload["videoDetails"]
        if not IsAssociativeArray(videoDetails)
            return {
                error: "Invalid video details"
            }
        end if

        streamingData = payload["streamingData"]
        if not IsAssociativeArray(streamingData)
            return {
                error: "Invalid streaming data"
            }
        end if

        lengthSeconds = videoDetails["lengthSeconds"].ToInt()

        videoInfo = {
            "type": "video"
            "title": videoDetails["title"]
            "videoId": videoDetails["videoId"]
            "videoThumbnails": videoDetails["thumbnail"]["thumbnails"]
            "storyboards": ParseStoryboards(payload, lengthSeconds)
            "author": videoDetails["author"]
            "authorId": videoDetails["channelId"]
            "lengthSeconds": lengthSeconds
            "liveNow": ValidBool(videoDetails["isLive"])
            "hlsUrl": streamingData["hlsManifestUrl"]
            "dashUrl": streamingData["dashManifestUrl"]
            "adaptiveFormats": ParseAdaptiveFormats(payload, sts, poToken)
            "formatStreams": []
            "captions": ParseCaptions(payload)
            "recommendedVideos": []
            ' TODO: refactor this
            "ytjs": true
        }

        if videoDetails.DoesExist("viewCount")
            videoInfo["viewCount"] = videoDetails["viewCount"].ToInt()
        end if

        return videoInfo
    end function

    function ParsePlayerResponseForError(payload as object) as string
        if not IsAssociativeArray(payload)
            return "Invalid payload"
        end if

        playabilityStatus = payload["playabilityStatus"]
        if not IsAssociativeArray(playabilityStatus)
            return "Invalid playability status"
        end if

        status = ValidString(playabilityStatus["status"])
        if status = "OK"
            return ""
        end if

        errorLines = []
        if not StringUtils.IsNullOrEmpty(playabilityStatus["reason"])
            errorLines.Push(playabilityStatus["reason"])
        end if

        if not StringUtils.IsNullOrEmpty(playabilityStatus["reasonTitle"])
            errorLines.Push(playabilityStatus["reasonTitle"])
        end if

        subreason = ParseText(ObjectUtils.Dig(playabilityStatus, ["errorScreen", "playerErrorMessageRenderer", "subreason"]))
        if subreason <> ""
            errorLines.Push(subreason)
        end if

        if errorLines.Count() = 0
            errorLines.Push("Video not available (Unknown)")
        end if

        if status = "LOGIN_REQUIRED"
            ' TODO:P2 localize
            errorLines.Push("Hint: Log in to the YouTube app on your phone, then cast the video to Playlet.")
        end if

        return errorLines.Join(`\n`)
    end function

    function ParseStoryboards(payload as object, lengthSeconds as integer) as object
        storyboard = ObjectUtils.Dig(payload, ["storyboards", "playerLiveStoryboardSpecRenderer", "spec"])
        if IsString(storyboard)
            storyboard = storyboard.Split("#")
            if storyboard.Count() <> 5
                return []
            end if
            return [{
                "templateUrl": storyboard[0]
                "width": storyboard[1].ToInt()
                "height": storyboard[2].ToInt()
                "count": -1
                "interval": 5000
                "storyboardHeight": storyboard[3].ToInt()
                "storyboardWidth": storyboard[4].ToInt()
            }]
        end if

        storyboards = ObjectUtils.Dig(payload, ["storyboards", "playerStoryboardSpecRenderer", "spec"])
        if not IsString(storyboards)
            return []
        end if

        storyboardsData = storyboards.Split("|")
        if storyboardsData.Count() < 2
            return []
        end if

        baseUrl = storyboardsData.Shift()
        storyboards = []

        index = 0
        for each sb in storyboardsData
            sbData = sb.Split("#")
            if sbData.Count() <> 8
                index += 1
                continue for
            end if

            width = sbData[0].ToInt()
            height = sbData[1].ToInt()
            _count = sbData[2].ToInt()
            columns = sbData[3].ToInt()
            rows = sbData[4].ToInt()
            interval = sbData[5].ToInt()
            name = sbData[6]
            sigh = sbData[7]

            url = baseUrl
            url = url.Replace("$L", `${index}`)
            url = url.Replace("$N", name)

            queryComponents = UrlUtils.ParseQueryComponents(url)
            queryComponents["sigh"] = sigh.DecodeUriComponent()
            url = UrlUtils.SetQueryParams(url, queryComponents)

            thumbnailsPerImage = columns * rows
            imagesCount = _count \ thumbnailsPerImage
            if _count mod thumbnailsPerImage > 0
                imagesCount += 1
            end if

            if interval = 0 and _count > 0
                interval = Cint(Cdbl(lengthSeconds) * 1000.0 / Cdbl(_count))
            end if

            storyboards.Push({
                "templateUrl": url
                "width": width
                "height": height
                "count": _count
                "interval": interval
                "storyboardWidth": columns
                "storyboardHeight": rows
                "storyboardCount": imagesCount
            })
            index += 1
        end for

        return storyboards
    end function

    function ParseCaptions(payload as object) as object
        tracks = ObjectUtils.Dig(payload, ["captions", "playerCaptionsTracklistRenderer", "captionTracks"])
        if not IsArray(tracks)
            return []
        end if

        captions = []
        for each track in tracks
            if not IsAssociativeArray(track)
                continue for
            end if

            baseUrl = track["baseUrl"]
            if not IsString(baseUrl)
                continue for
            end if

            queryComponents = UrlUtils.ParseQueryComponents(baseUrl)
            queryComponents["fmt"] = "vtt"
            baseUrl = UrlUtils.SetQueryParams(baseUrl, queryComponents)

            languageCode = track["languageCode"]
            if not IsString(languageCode)
                continue for
            end if

            label = ""
            name = track["name"]
            if IsAssociativeArray(name)
                runs = name["runs"]
                if IsArray(runs)
                    for each rn in runs
                        text = rn["text"]
                        if IsString(text)
                            label += text
                        end if
                    end for
                end if
            end if

            captions.Push({
                "label": label
                "language_code": languageCode
                "url": baseUrl
            })
        end for

        return captions
    end function

    function ParseAdaptiveFormats(payload as object, sts as dynamic, poToken as dynamic) as object
        adaptiveFormats = ObjectUtils.Dig(payload, ["streamingData", "adaptiveFormats"])
        if not IsArray(adaptiveFormats)
            return []
        end if

        adaptiveFormats = DecipherUrls(adaptiveFormats, sts, poToken)

        formatInfos = AdaptiveFormatInfos()
        formats = []
        for each fmt in adaptiveFormats
            formats.Push(GetAdaptiveFormat(fmt, formatInfos))
        end for

        return formats
    end function

    function GetAdaptiveFormat(fmt as object, formatInfos as object) as object
        itag = `${fmt["itag"]}`
        formatInfo = formatInfos[itag]
        result = {
            "bitrate": `${fmt["bitrate"]}`
            "url": fmt["url"]
            "itag": itag
            "type": fmt["mimeType"]
            "clen": `${fmt["approxDurationMs"]}`
            "lmt": `${fmt["lastModified"]}`
        }

        if IsAssociativeArray(formatInfo)
            result["container"] = formatInfo["ext"]
        else
            LogWarn("Unknown itag:", itag)
            ' #if DEBUG
            '     throw "Unknown itag: " + itag
            ' #end if
        end if

        if IsAssociativeArray(fmt["initRange"])
            result["init"] = `${fmt["initRange"]["start"]}-${fmt["initRange"]["end"]}`
        else
            result["init"] = ""
        end if
        if IsAssociativeArray(fmt["indexRange"])
            result["index"] = `${fmt["indexRange"]["start"]}-${fmt["indexRange"]["end"]}`
        else
            result["index"] = ""
        end if

        if IsString(fmt["audioQuality"])
            result["audioQuality"] = fmt["audioQuality"]
        end if
        if IsString(fmt["audioSampleRate"])
            result["audioSampleRate"] = fmt["audioSampleRate"]
        end if
        if IsString(fmt["audioChannels"])
            result["audioChannels"] = fmt["audioChannels"]
        end if

        if IsString(fmt["qualityLabel"])
            result["qualityLabel"] = fmt["qualityLabel"]
        end if
        if IsString(fmt["fps"])
            result["fps"] = fmt["fps"]
        end if
        if fmt["width"] <> invalid and fmt["height"] <> invalid
            result["size"] = `${fmt["width"]}x${fmt["height"]}`
            result["resolution"] = `${fmt["height"]}p`
        else if IsAssociativeArray(formatInfo) and formatInfo.DoesExist("width") and formatInfo.DoesExist("height")
            result["size"] = `${formatInfo["width"]}x${formatInfo["height"]}`
            result["resolution"] = `${formatInfo["height"]}p`
        end if

        return result
    end function

    function GetSts() as dynamic
        cache = ReadAsciiFile("tmp:/sts_cache.json")
        if not StringUtils.IsNullOrEmpty(cache)
            json = ParseJson(cache)
            return json["sts"]
        end if

        request = HttpClient.Get(`${DECHIPHER_SERVER}/v1/sts`)
        response = request.Await()
        if not response.IsSuccess()
            LogError(response.ErrorMessage())
            return invalid
        end if

        text = response.Text()
        WriteAsciiFile("tmp:/sts_cache.json", text)
        json = response.Json()
        return json["sts"]
    end function

    function DecipherUrls(adaptiveFormats as object, sts as dynamic, poToken as dynamic) as object
        if sts = invalid
            ' No need to decipher if sts is not available
            return adaptiveFormats
        end if

        formats = []
        for each fmt in adaptiveFormats
            formats.push({
                "url": fmt["url"]
                "cipher": fmt["cipher"]
                "signatureCipher": fmt["signatureCipher"]
            })
        end for

        request = HttpClient.PostJson(`${DECHIPHER_SERVER}/v1/decipher`, {
            "sts": sts
            "formats": formats
            "poToken": poToken
        })

        request.LogCurlCommand(false)

        response = request.Await()
        if not response.IsSuccess()
            if response.StatusCode() = 400
                json = response.Json()
                if IsAssociativeArray(json) and json["code"] = "STS_MISMATCH"
                    DeleteFile("tmp:/sts_cache.json")
                end if
            end if
            LogError(response.ErrorMessage())
            return adaptiveFormats
        end if

        json = response.Json()
        if not IsAssociativeArray(json) or not json.DoesExist("formats")
            LogError("Invalid response from decipher service")
            return adaptiveFormats
        end if

        decipheredFormats = json["formats"]
        if not IsArray(decipheredFormats) or decipheredFormats.Count() <> adaptiveFormats.Count()
            LogError("Invalid formats in deciphered response")
            return adaptiveFormats
        end if

        for i = 0 to decipheredFormats.Count() - 1
            fmt = adaptiveFormats[i]
            decipheredFmt = decipheredFormats[i]

            fmt["url"] = decipheredFmt["url"]
        end for

        return adaptiveFormats
    end function

    function AdaptiveFormatInfos() as object
        return {
            "5": { ext: "flv", width: 400, height: 240, acodec: "mp3", abr: 64, vcodec: "h263" }
            "6": { ext: "flv", width: 450, height: 270, acodec: "mp3", abr: 64, vcodec: "h263" }
            "13": { ext: "3gp", acodec: "aac", vcodec: "mp4v" }
            "17": { ext: "3gp", width: 176, height: 144, acodec: "aac", abr: 24, vcodec: "mp4v" }
            "18": { ext: "mp4", width: 640, height: 360, acodec: "aac", abr: 96, vcodec: "h264" }
            "22": { ext: "mp4", width: 1280, height: 720, acodec: "aac", abr: 192, vcodec: "h264" }
            "34": { ext: "flv", width: 640, height: 360, acodec: "aac", abr: 128, vcodec: "h264" }
            "35": { ext: "flv", width: 854, height: 480, acodec: "aac", abr: 128, vcodec: "h264" }
            "36": { ext: "3gp", width: 320, acodec: "aac", vcodec: "mp4v" }
            "37": { ext: "mp4", width: 1920, height: 1080, acodec: "aac", abr: 192, vcodec: "h264" }
            "38": { ext: "mp4", width: 4096, height: 3072, acodec: "aac", abr: 192, vcodec: "h264" }
            "43": { ext: "webm", width: 640, height: 360, acodec: "vorbis", abr: 128, vcodec: "vp8" }
            "44": { ext: "webm", width: 854, height: 480, acodec: "vorbis", abr: 128, vcodec: "vp8" }
            "45": { ext: "webm", width: 1280, height: 720, acodec: "vorbis", abr: 192, vcodec: "vp8" }
            "46": { ext: "webm", width: 1920, height: 1080, acodec: "vorbis", abr: 192, vcodec: "vp8" }
            "59": { ext: "mp4", width: 854, height: 480, acodec: "aac", abr: 128, vcodec: "h264" }
            "78": { ext: "mp4", width: 854, height: 480, acodec: "aac", abr: 128, vcodec: "h264" }
            "82": { ext: "mp4", height: 360, format: "3D", acodec: "aac", abr: 128, vcodec: "h264" }
            "83": { ext: "mp4", height: 480, format: "3D", acodec: "aac", abr: 128, vcodec: "h264" }
            "84": { ext: "mp4", height: 720, format: "3D", acodec: "aac", abr: 192, vcodec: "h264" }
            "85": { ext: "mp4", height: 1080, format: "3D", acodec: "aac", abr: 192, vcodec: "h264" }
            "100": { ext: "webm", height: 360, format: "3D", acodec: "vorbis", abr: 128, vcodec: "vp8" }
            "101": { ext: "webm", height: 480, format: "3D", acodec: "vorbis", abr: 192, vcodec: "vp8" }
            "102": { ext: "webm", height: 720, format: "3D", acodec: "vorbis", abr: 192, vcodec: "vp8" }
            "91": { ext: "mp4", height: 144, format: "HLS", acodec: "aac", abr: 48, vcodec: "h264" }
            "92": { ext: "mp4", height: 240, format: "HLS", acodec: "aac", abr: 48, vcodec: "h264" }
            "93": { ext: "mp4", height: 360, format: "HLS", acodec: "aac", abr: 128, vcodec: "h264" }
            "94": { ext: "mp4", height: 480, format: "HLS", acodec: "aac", abr: 128, vcodec: "h264" }
            "95": { ext: "mp4", height: 720, format: "HLS", acodec: "aac", abr: 256, vcodec: "h264" }
            "96": { ext: "mp4", height: 1080, format: "HLS", acodec: "aac", abr: 256, vcodec: "h264" }
            "132": { ext: "mp4", height: 240, format: "HLS", acodec: "aac", abr: 48, vcodec: "h264" }
            "151": { ext: "mp4", height: 72, format: "HLS", acodec: "aac", abr: 24, vcodec: "h264" }
            "133": { ext: "mp4", height: 240, format: "DASH video", vcodec: "h264" }
            "134": { ext: "mp4", height: 360, format: "DASH video", vcodec: "h264" }
            "135": { ext: "mp4", height: 480, format: "DASH video", vcodec: "h264" }
            "136": { ext: "mp4", height: 720, format: "DASH video", vcodec: "h264" }
            "137": { ext: "mp4", height: 1080, format: "DASH video", vcodec: "h264" }
            "138": { ext: "mp4", format: "DASH video", vcodec: "h264" }
            "160": { ext: "mp4", height: 144, format: "DASH video", vcodec: "h264" }
            "212": { ext: "mp4", height: 480, format: "DASH video", vcodec: "h264" }
            "264": { ext: "mp4", height: 1440, format: "DASH video", vcodec: "h264" }
            "298": { ext: "mp4", height: 720, format: "DASH video", vcodec: "h264", fps: 60 }
            "299": { ext: "mp4", height: 1080, format: "DASH video", vcodec: "h264", fps: 60 }
            "266": { ext: "mp4", height: 2160, format: "DASH video", vcodec: "h264" }
            "139": { ext: "m4a", format: "DASH audio", acodec: "aac", abr: 48, container: "m4a_dash" }
            "140": { ext: "m4a", format: "DASH audio", acodec: "aac", abr: 128, container: "m4a_dash" }
            "141": { ext: "m4a", format: "DASH audio", acodec: "aac", abr: 256, container: "m4a_dash" }
            "256": { ext: "m4a", format: "DASH audio", acodec: "aac", container: "m4a_dash" }
            "258": { ext: "m4a", format: "DASH audio", acodec: "aac", container: "m4a_dash" }
            "325": { ext: "m4a", format: "DASH audio", acodec: "dtse", container: "m4a_dash" }
            "328": { ext: "m4a", format: "DASH audio", acodec: "ec-3", container: "m4a_dash" }
            "167": { ext: "webm", height: 360, width: 640, format: "DASH video", container: "webm", vcodec: "vp8" }
            "168": { ext: "webm", height: 480, width: 854, format: "DASH video", container: "webm", vcodec: "vp8" }
            "169": { ext: "webm", height: 720, width: 1280, format: "DASH video", container: "webm", vcodec: "vp8" }
            "170": { ext: "webm", height: 1080, width: 1920, format: "DASH video", container: "webm", vcodec: "vp8" }
            "218": { ext: "webm", height: 480, width: 854, format: "DASH video", container: "webm", vcodec: "vp8" }
            "219": { ext: "webm", height: 480, width: 854, format: "DASH video", container: "webm", vcodec: "vp8" }
            "278": { ext: "webm", height: 144, format: "DASH video", container: "webm", vcodec: "vp9" }
            "242": { ext: "webm", height: 240, format: "DASH video", vcodec: "vp9" }
            "243": { ext: "webm", height: 360, format: "DASH video", vcodec: "vp9" }
            "244": { ext: "webm", height: 480, format: "DASH video", vcodec: "vp9" }
            "245": { ext: "webm", height: 480, format: "DASH video", vcodec: "vp9" }
            "246": { ext: "webm", height: 480, format: "DASH video", vcodec: "vp9" }
            "247": { ext: "webm", height: 720, format: "DASH video", vcodec: "vp9" }
            "248": { ext: "webm", height: 1080, format: "DASH video", vcodec: "vp9" }
            "271": { ext: "webm", height: 1440, format: "DASH video", vcodec: "vp9" }
            "272": { ext: "webm", height: 2160, format: "DASH video", vcodec: "vp9" }
            "302": { ext: "webm", height: 720, format: "DASH video", vcodec: "vp9", fps: 60 }
            "303": { ext: "webm", height: 1080, format: "DASH video", vcodec: "vp9", fps: 60 }
            "308": { ext: "webm", height: 1440, format: "DASH video", vcodec: "vp9", fps: 60 }
            "313": { ext: "webm", height: 2160, format: "DASH video", vcodec: "vp9" }
            "315": { ext: "webm", height: 2160, format: "DASH video", vcodec: "vp9", fps: 60 }
            "330": { ext: "webm", height: 144, format: "DASH video", vcodec: "vp9", fps: 60 }
            "331": { ext: "webm", height: 240, format: "DASH video", vcodec: "vp9", fps: 60 }
            "332": { ext: "webm", height: 360, format: "DASH video", vcodec: "vp9", fps: 60 }
            "333": { ext: "webm", height: 480, format: "DASH video", vcodec: "vp9", fps: 60 }
            "334": { ext: "webm", height: 720, format: "DASH video", vcodec: "vp9", fps: 60 }
            "335": { ext: "webm", height: 1080, format: "DASH video", vcodec: "vp9", fps: 60 }
            "336": { ext: "webm", height: 1440, format: "DASH video", vcodec: "vp9", fps: 60 }
            "337": { ext: "webm", height: 2160, format: "DASH video", vcodec: "vp9", fps: 60 }
            "171": { ext: "webm", acodec: "vorbis", format: "DASH audio", abr: 128 }
            "172": { ext: "webm", acodec: "vorbis", format: "DASH audio", abr: 256 }
            "249": { ext: "webm", format: "DASH audio", acodec: "opus", abr: 50 }
            "250": { ext: "webm", format: "DASH audio", acodec: "opus", abr: 70 }
            "251": { ext: "webm", format: "DASH audio", acodec: "opus", abr: 160 }
            "394": { ext: "mp4", height: 144, vcodec: "av01.0.05M.08" }
            "395": { ext: "mp4", height: 240, vcodec: "av01.0.05M.08" }
            "396": { ext: "mp4", height: 360, vcodec: "av01.0.05M.08" }
            "397": { ext: "mp4", height: 480, vcodec: "av01.0.05M.08" }
        }
    end function
end namespace
