#const SUPPORTS_BATCHING = false

import "pkg:/components/Telemetry/Sentry.bs"
import "pkg:/source/utils/Logging.bs"
import "pkg:/source/utils/Types.bs"

function Init() as void
    if m.global.telemetry <> invalid
        return
    end if
    m.global.addFields({ telemetry: m.top })
    m.top.functionName = "TelemetryLoop"
end function

function OnNodeReady() as void
    m.deviceInfo = CreateObject("roDeviceInfo")
    m.tags = GetTags()
    m.release = GetRelease(m.tags)
    m.dist = GetDist(m.tags)
    m.userId = GetUserId()

    m.top.ObserveField("enabled", FuncName(OnEnabledChanged))
    m.preferences.ObserveFieldScoped("dev.diagnostics.enabled", FuncName(OnPreferencesChanged))
    enabled = m.preferences["dev.diagnostics.enabled"]
    OnPreferencesChanged({
        enabled: enabled
        getData: function() as boolean
            return m.enabled
        end function
    })
end function

function OnPreferencesChanged(event as object) as void
    m.top.enabled = event.getData()
end function

function OnEnabledChanged(event as object) as void
    enabled = event.getData()
    LogInfo("Telemetry enabled:", enabled)
    if enabled
        m.top.control = "run"
    else
        m.top.control = "stop"
    end if
end function

function TelemetryLoop() as void
    msgPort = CreateObject("roMessagePort")
    m.top.observeField("LogInfo", msgPort)
    m.top.observeField("LogWarn", msgPort)
    m.top.observeField("LogError", msgPort)
    m.top.observeField("LogEvent", msgPort)

    #if SUPPORTS_BATCHING
        debouceMs = 2000
        debounceCountLimit = 20
        debounceTimeLimit = 5000
        debounceTimer = CreateObject("roTimeSpan")
    #end if

    retryAfter = 0
    retryAfterTimer = CreateObject("roTimeSpan")

    levelMap = {
        "LogInfo": "info"
        "LogWarn": "warning"
        "LogError": "error"
    }

    messages = []
    events = []

    while true
        msg = wait(0, msgPort)

        if retryAfter > 0
            if retryAfterTimer.TotalMilliseconds() < retryAfter * 1000
                continue while
            else
                retryAfter = 0
            end if
        end if

        messages.Push(msg)

        #if SUPPORTS_BATCHING
            debounceTimer.Mark()
            while true
                LogDebug("Waiting for more messages...")
                msg = wait(debouceMs, msgPort)
                if msg = invalid
                    LogDebug("No more messages")
                    exit while
                end if
                messages.Push(msg)
                if messages.Count() >= debounceCountLimit
                    LogDebug("Reached debounce count limit")
                    exit while
                end if
                if debounceTimer.TotalMilliseconds() >= debounceTimeLimit
                    LogDebug("Reached debounce time limit")
                    exit while
                end if
            end while
        #end if

        events.Clear()
        for each msg in messages
            msgType = type(msg)
            if msgType <> "roSGNodeEvent"
                continue for
            end if

            field = msg.getField()

            if levelMap.DoesExist(field)
                events.Push({
                    level: levelMap[field]
                    message: msg.getData()
                    release: m.release
                    dist: m.dist
                    tags: m.tags
                    userId: m.userId
                })
            else if field = "LogEvent"
                data = msg.getData()
                events.Push({
                    level: data.level
                    message: data.message
                    release: m.release
                    dist: m.dist
                    tags: m.tags
                    userId: m.userId
                    fingerprint: data.fingerprint
                    attachments: data.attachments
                })
            end if
        end for
        messages.Clear()

        if events.Count() = 0
            continue while
        end if

        retryAfter = Sentry.SendEvents(events)
        if retryAfter > 0
            retryAfterTimer.Mark()
        end if
    end while
end function

function GetTags() as object
    appInfo = m.applicationInfo
    tags = appInfo@.GetAppInfo()
    tags.Append(appInfo@.GetDeviceInfo())

    tags.Delete("friendly_name")

    for each key in tags
        if not IsString(tags[key])
            tags[key] = ToString(tags[key])
        end if
    end for

    ' A session ID in this case acts as single trace ID for all events sent during a single app session
    ' For example, to understand why a requested hit a 403, it could be explained by a previous
    ' refresh token failure event that happened earlier in the same session
    tags["session_id"] = m.deviceInfo.GetRandomUUID()

    return tags
end function

function GetRelease(tags as object) as string
    return`${tags["lib_version"]}-${tags["lib_git_commit_hash"]}`
end function

function GetDist(tags as object) as string
    dist = `${tags["app_version"]}-${tags["app_git_commit_hash"]}-${tags["lib_version"]}-${tags["lib_git_commit_hash"]}`
    if tags["id"] = "dev"
        dist = dist + "-dev"
    end if
    return dist
end function

function GetUserId() as string
    return CreateObject("roDeviceInfo").GetChannelClientId()
end function
