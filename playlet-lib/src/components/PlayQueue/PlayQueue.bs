import "pkg:/components/Dialog/DialogUtils.bs"
import "pkg:/components/NodeByRef/NodeByRef.bs"
import "pkg:/components/PlayQueue/Notifications/PlayQueueNotificationUtils.bs"
import "pkg:/components/VideoFeed/FeedLoadState.bs"
import "pkg:/components/VideoPlayer/VideoUtils.bs"
import "pkg:/source/AsyncTask/AsyncTask.bs"
import "pkg:/source/AsyncTask/Tasks.bs"
import "pkg:/source/utils/ArrayUtils.bs"
import "pkg:/source/utils/ErrorUtils.bs"
import "pkg:/source/utils/Logging.bs"
import "pkg:/source/utils/RingBuffer.bs"
import "pkg:/source/utils/Types.bs"

' TODO:P1 prevent adding duplicates of the same video/playlist
function Init()
    m.pendingLoadTasks = {}
    m.content = m.top.findNode("Content")
    m.top.content = m.content
    m.content.addField("index", "integer", false)
    m.content.index = m.top.index
    ' TODO:P2 use actual queue nodes instead of internal buffer
    m.watchedVideos = new RingBuffer(100)
end function

function Play(node as object, playlistIndex as integer)
    m.top.index += 1
    m.top.playlistIndex = playlistIndex

    node = WrapWithIndexField(node)
    if m.top.index >= m.content.getChildCount()
        m.content.appendChild(node)
        m.top.index = m.content.getChildCount() - 1
    else
        m.content.insertChild(node, m.top.index)
    end if

    PlayItemAtCurrentIndex()
end function

function AddToQueue(node as object)
    node = WrapWithIndexField(node)
    m.content.appendChild(node)
    queueNotifications = m.top.preferences["misc.queue_notifications"]
    if queueNotifications
        hintVisible = VideoUtils.GetVideoPlayer() = invalid or not VideoUtils.IsVideoPlayerFullScreen()
        PlayQueue.ShowNotifcation(m.top.notifications, node, hintVisible)
    end if
end function

function WrapWithIndexField(node as object) as object
    node = NodeByRef.Wrap(node)
    if not node.hasField("index")
        node.addField("index", "integer", false)
    end if
    node.index = m.top.index
    return node
end function

' TODO:P0 better model of the queue (Now playing, etc)
function GetQueue(_unused as dynamic) as object
    queueNodes = m.content.getChildren(-1, 0)
    items = []
    for each node in queueNodes
        node = NodeByRef.Unwrap(node)
        if node = invalid
            continue for
        end if

        nodeType = node.type
        if nodeType = "video"
            items.push({
                type: nodeType
                videoId: node.videoId
                title: node.title
                author: node.author
                thumbnail: node.thumbnail
            })
        else if node.type = "playlist"
            items.push({
                type: nodeType
                playlistId: node.playlistId
                title: node.title
                thumbnail: node.thumbnail
                videoCountText: node.videoCountText
            })
        end if
    end for

    return {
        index: m.top.index
        playlistIndex: m.top.playlistIndex
        items: items
    }
end function

function Clear(_unused as dynamic)
    m.content.removeChildrenIndex(m.content.getChildCount(), 0)
    m.top.index = -1
    m.top.playlistIndex = -1
end function

function PlayNextItem(_unused as dynamic) as boolean
    childCount = m.content.getChildCount()
    if childCount = 0
        return false
    end if

    index = m.top.index
    if index <> -1
        if index >= childCount
            return false
        end if
        node = m.content.getChild(index)
        node = NodeByRef.Unwrap(node)
        if node.type = "playlist"
            m.top.playlistIndex += 1
            if PlayPlaylistAtCurrentIndex(node)
                return true
            end if
        end if
    end if

    m.top.index += 1
    m.top.playlistIndex = -1
    if m.top.index >= childCount
        return false
    end if

    return PlayItemAtCurrentIndex()
end function

function PlayItemAtIndex(index as integer) as boolean
    m.top.index = index
    m.top.playlistIndex = -1
    return PlayItemAtCurrentIndex()
end function

function PlayItemAtCurrentIndex() as boolean
    node = m.content.getChild(m.top.index)
    node = NodeByRef.Unwrap(node)
    if node = invalid
        return false
    end if
    if node.type = "video"
        PlayVideo(node)
        return true
    else if node.type = "playlist"
        if m.top.playlistIndex = -1
            m.top.playlistIndex = 0
        end if
        return PlayPlaylistAtCurrentIndex(node)
    end if
    return false
end function

function PlayPlaylistAtCurrentIndex(playlist as object) as boolean
    playlist = NodeByRef.Unwrap(playlist)
    if playlist.videoCount < 0
        LoadPlaylist(playlist)
        return true
    end if
    playlistIndex = m.top.playlistIndex
    if playlistIndex < 0 or playlistIndex >= playlist.videoCount
        return false
    end if

    if playlistIndex < playlist.getChildCount()
        child = playlist.getChild(playlistIndex)
        PlayVideo(child)
        return true
    end if

    LoadPlaylist(playlist)
    return true
end function

function PlayVideo(node as object)
    videoId = node.videoId
    if not m.watchedVideos.Contains(videoId)
        m.watchedVideos.Push(videoId)
    end if
    VideoUtils.PlayVideo(node)
end function

function LoadPlaylist(playlist as object) as void
    if playlist.loadState = FeedLoadState.Loading
        return
    end if

    playlist.loadState = FeedLoadState.Loading

    task = AsyncTask.Start(Tasks.PlaylistContentTask, {
        content: playlist
        invidious: m.top.invidious
        continueWatchingContent: m.top.continueWatching.content
    }, OnPlaylistContentTaskResult)
    m.pendingLoadTasks[task.id] = task
end function

function OnPlaylistContentTaskResult(output as object) as void
    m.pendingLoadTasks.Delete(output.task.id)

    if output.cancelled
        return
    end if

    playlist = output.task.input.content
    if not output.success or not output.result.success
        ' output.error for unhandled exception
        error = output.error
        if error = invalid
            ' output.result.error for network errors
            error = output.result.error
        end if
        error = ErrorUtils.Format(error)
        LogError(error)
        playlistId = playlist.playlistId
        message = `Failed to load playlist ${playlistId}\n${error}`
        ' TODO:P1 play next upon closing the dialog
        DialogUtils.ShowDialog(message, "Playlist load fail", true)
        return
    end if

    PlayPlaylistAtCurrentIndex(playlist)
end function

function OnIndexChange()
    index = m.top.index
    m.content.index = index
    children = m.top.content.getChildren(-1, 0)
    for each child in children
        child.index = index
    end for
end function

function watchedVideosContain(videoId as string) as boolean
    return m.watchedVideos.Contains(videoId)
end function

function watchedVideosClear(_unused as dynamic)
    m.watchedVideos = new RingBuffer(100)
end function
