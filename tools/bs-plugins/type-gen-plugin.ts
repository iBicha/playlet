// This plugin generates a file containing functions for type checking and type casting.
import { CompilerPlugin, Program, SourceObj } from "brighterscript";
import path from "path";

const types = [
    { name: 'Bool', interface: 'ifBoolean', type: 'boolean', defaultValue: 'false' },
    { name: 'Int', interface: 'ifInt', type: 'integer', defaultValue: '0%' },
    { name: 'Float', interface: 'ifFloat', type: 'float', defaultValue: '0!' },
    { name: 'Double', interface: 'ifDouble', type: 'double', defaultValue: '0#' },
    { name: 'String', interface: 'ifString', type: 'string', defaultValue: '""' },
    { name: 'Array', interface: 'ifArray', type: 'object', defaultValue: 'CreateObject("roArray", 0, true)' },
    { name: 'AssociativeArray', interface: 'ifAssociativeArray', type: 'object', defaultValue: '{}' },
    { name: 'ByteArray', interface: 'ifByteArray', type: null, defaultValue: null },
    { name: 'Function', interface: 'ifFunction', type: null, defaultValue: null },
    { name: 'Node', interface: 'ifSGNodeDict', type: null, defaultValue: null },
];

const generatedCodeHeader = `' The rest of this file is generated by the TypeGenPlugin`

const typesFilePath = path.join("source", "utils", "Types.bs");

const isTypeTemplate = (name: string, _interface: string) => {
    return `' Returns true if the given object is of type ${name}, false otherwise
function Is${name}(obj as dynamic) as boolean
    return obj <> invalid and GetInterface(obj, "${_interface}") <> invalid
end function`;
};

const validTypeTemplate = (name: string, type: string, _interface: string, defaultValue: string) => {
    return `' Returns the given object if it is of type ${name}, otherwise returns the default value \`${defaultValue}\`
function Valid${name}(obj as dynamic) as ${type}
    if obj <> invalid and GetInterface(obj, "${_interface}") <> invalid
        return obj
    else
        return ${defaultValue}
    end if
end function`;
}

export class TypeGenPlugin implements CompilerPlugin {
    public name = 'TypeGenPlugin';

    program: Program | undefined;

    afterProgramCreate(program: Program) {
        this.program = program;
    }

    beforeFileParse(source: SourceObj) {
        if (!source.srcPath.endsWith(typesFilePath)) {
            return;
        }

        if (source.source.includes(generatedCodeHeader)) {
            return;
        }

        let generatedCode = `\n${generatedCodeHeader}\n\n`;

        types.forEach(type => {
            generatedCode += `${isTypeTemplate(type.name, type.interface)}\n`;
            if (type.type !== null && type.defaultValue !== null) {
                generatedCode += `${validTypeTemplate(type.name, type.type, type.interface, type.defaultValue)}\n`;
            }
        });

        const fileContents = source.source + generatedCode;
        this.program!.setFile(source.srcPath, fileContents)
    }
}

export default () => {
    return new TypeGenPlugin();
};
